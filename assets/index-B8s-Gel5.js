var Y=Object.defineProperty;var G=(E,e,t)=>e in E?Y(E,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):E[e]=t;var n=(E,e,t)=>G(E,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const a of o)if(a.type==="childList")for(const c of a.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&s(c)}).observe(document,{childList:!0,subtree:!0});function t(o){const a={};return o.integrity&&(a.integrity=o.integrity),o.referrerPolicy&&(a.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?a.credentials="include":o.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(o){if(o.ep)return;o.ep=!0;const a=t(o);fetch(o.href,a)}})();class q{constructor(){n(this,"distanceF",(e,t,s,o,a,c)=>Math.sqrt((o-e)**2+(a-t)**2+(c-s)**2));n(this,"generateEdgeKey",(e,t,s,o)=>(t?e[0]+(t%o?t:""):"")+(s?e[1]+(s%o?s:""):""));n(this,"generateKeyName",(e,t,s,o,a)=>`${t?`${e[0]}${t%a?t:""}`:""}${s?`${e[1]}${s%a?s:""}`:""}${o?`${e[2]}${o%a?o:""}`:""}`);n(this,"calculateConnectedFaces",(e,t,s)=>{const o=[];if(s<3)throw new Error("cannot calculate faces of an edge");const a=t.length;for(let c=0;c<a;c++){const r=[];r.push(e);for(let i=c;i<c+s-1;i++)r.push(t[i%a]);o.push(r.join("-"))}return o});n(this,"numFromChar",e=>e.charCodeAt(0)-97);n(this,"mapChar",e=>String.fromCharCode(e+97));n(this,"averageZ",(e,t)=>(e+t)/2);n(this,"mapToChars",e=>e.map(t=>this.mapChar(t)));n(this,"calculateRotatedCoordinates",(e,t,s,o,a,c,r)=>{const i=Math.sin(r*o),d=Math.cos(r*o),l=-Math.sin(r*a),b=Math.cos(r*a),g=Math.sin(r*c),f=Math.cos(r*c),C=e*f*d+t*f*i*l-t*g*b+s*f*i*b+s*g*l,w=e*g*d+t*g*i*l+t*f*b+s*g*i*b-s*f*l,F=-e*i+t*d*l+s*d*b;return{x:C,y:w,z:F}});n(this,"icosahedronIntermediateNode",(e,t,s,o,a,c,r,i,d,l,b,g)=>{const f=e+t+s,C=o*(e/f)+r*(t/f)+l*(s/f),w=a*(e/f)+i*(t/f)+b*(s/f),F=c*(e/f)+d*(t/f)+g*(s/f),B=this.distanceF(C,w,F,0,0,0);return{x:C/B,y:w/B,z:F/B}})}}class X{constructor(e,t,s){n(this,"utils");n(this,"ctx");n(this,"width");n(this,"height");n(this,"centerX");n(this,"centerY");n(this,"clearCanvas",()=>{this.ctx&&(this.ctx.fillStyle="white",this.ctx.fillRect(0,0,this.width,this.height))});n(this,"d",(e,t,s=!1)=>e*(1+t/4e3)+(s?this.centerX:this.centerY));n(this,"draw",(e,t,s)=>{this.clearCanvas();const{frontNodes:o,backNodes:a,frontBaseNodes:c,backBaseNodes:r,frontEdges:i,backEdges:d,frontBaseEdges:l,backBaseEdges:b,frontFaces:g,backFaces:f,frontBaseFaces:C,backBaseFaces:w}=this.separate(e);t.baseNodes%3&&this.drawNodes(r,s.baseNodeSize,s.backBaseNodeColor),t.nodes%3&&this.drawNodes(a,s.nodeSize,s.backNodeColor),t.faces%3&&this.drawFaces(f,s.backFaceColor,s.backFaceEdgeColor),t.edges%3&&this.drawEdges(d,s.edgeWidth,s.backEdgeColor),t.baseFaces%3&&this.drawFaces(w,s.backBaseFaceColor,s.backBaseFaceEdgeColor),t.baseEdges%3&&this.drawEdges(b,s.baseEdgeWidth,s.backBaseEdgeColor),t.baseEdges>1&&this.drawEdges(l,s.baseEdgeWidth,s.baseEdgeColor),t.baseFaces>1&&this.drawFaces(C,s.baseFaceColor,s.baseFaceEdgeColor),t.edges>1&&this.drawEdges(i,s.edgeWidth,s.edgeColor),t.faces>1&&this.drawFaces(g,s.faceColor,s.faceEdgeColor),t.nodes>1&&this.drawNodes(o,s.nodeSize,s.nodeColor),t.baseNodes>1&&this.drawNodes(c,s.baseNodeSize,s.baseNodeColor)});n(this,"labelNode",(e,t,s)=>{if(!this.ctx)return;const o=20;this.ctx.font=`Bold ${4*o}px Arial`,this.ctx.fillStyle="#FF00A6",this.ctx.fillText(s.toUpperCase(),e-o,t+o)});n(this,"labelNodes",e=>{for(const t of e){const[s,o,a]=t;this.labelNode(s,o,a)}});n(this,"drawNode",(e,t,s,o)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.arc(e,t,s,0,2*Math.PI),this.ctx.fillStyle=o,this.ctx.fill())});n(this,"drawEdge",(e,t,s,o,a,c)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.moveTo(e,t),this.ctx.lineTo(s,o),this.ctx.lineWidth=a,this.ctx.strokeStyle=c,this.ctx.stroke())});n(this,"drawFace",(e,t,s)=>{if(this.ctx){this.ctx.beginPath(),this.ctx.strokeStyle=s,this.ctx.fillStyle=t,this.ctx.lineWidth=2,this.ctx.moveTo(e[0][0],e[0][1]);for(let o=1;o<e.length;o++)this.ctx.lineTo(e[o][0],e[o][1]);this.ctx.lineTo(e[0][0],e[0][1]),this.ctx.fill()}});n(this,"drawNodes",(e,t,s)=>{for(const[o,a]of e)this.drawNode(o,a,t,s)});n(this,"drawEdges",(e,t,s)=>{for(let o=0;o<e.length;o++){const[a,c,r,i]=e[o];this.drawEdge(a,c,r,i,t,s)}});n(this,"drawFaces",(e,t,s)=>{for(let o=0;o<e.length;o++)this.drawFace(e[o],t,s)});n(this,"separate",e=>{const t=[],s=[],o=[],a=[],c=[],r=[],i=[],d=[],l=[],b=[],g=[],f=[],C=[],w=new Set,F=new Set,B=new Set,P=new Set;for(const N of e.keys()){const S=N.length===1,x=e.get(N),{edges:M,baseEdges:I,faces:Z,baseFaces:$}=x.connections,m=this.d(x.x,x.z,!0),z=this.d(x.y,x.z);if(x.z>=0?(t.push([m,z]),S&&o.push([m,z])):(s.push([m,z]),S&&a.push([m,z])),S&&x.z>=0&&C.push([m,z,N]),I)for(let h=0;h<I.length;h++){if(F.has([I[h],N].sort().join("")))continue;const u=e.get(I[h]).z,p=this.d(e.get(I[h]).x,u,!0),y=this.d(e.get(I[h]).y,u);this.utils.averageZ(x.z,u)>=0?i.push([m,z,p,y]):d.push([m,z,p,y]),F.add([I[h],N].sort().join(""))}if($)for(let h=0;h<$.length;h++){if(P.has($[h].split("-").sort().join("")))continue;const u=[];let p=0;for(const y of $[h].split("-")){const{x:k,y:T,z:v}=e.get(y);p+=v,u.push([this.d(k,v,!0),this.d(T,v)])}p/3>=0?g.push(u):f.push(u),P.add($[h].split("-").sort().join(""))}for(let h=0;h<M.length;h++){if(w.has([M[h],N].sort().join(""))||!e.get(M[h]))continue;const u=e.get(M[h]).z,p=this.d(e.get(M[h]).x,u,!0),y=this.d(e.get(M[h]).y,u);this.utils.averageZ(x.z,u)>=0?c.push([m,z,p,y]):r.push([m,z,p,y]),w.add([M[h],N].sort().join(""))}for(let h=0;h<Z.length;h++){if(B.has(Z[h].split("-").sort().join("")))continue;const u=[];let p=0;for(const y of Z[h].split("-")){const{x:k,y:T,z:v}=e.get(y);p+=v,u.push([this.d(k,v,!0),this.d(T,v)])}p/3>=0?l.push(u):b.push(u),B.add(Z[h].split("-").sort().join(""))}}return{frontNodes:t,backNodes:s,frontBaseNodes:o,backBaseNodes:a,frontEdges:c,backEdges:r,frontBaseEdges:i,backBaseEdges:d,frontFaces:l,backFaces:b,frontBaseFaces:g,backBaseFaces:f,labelNodes:C}});e.width=t,e.height=s,this.utils=new q,this.ctx=e.getContext("2d"),this.width=t,this.height=s,this.centerX=t/2,this.centerY=s/2}}class R{constructor(e,t){n(this,"canvasParent");n(this,"panelParent");n(this,"panelId");n(this,"canvasId");n(this,"mouseIsDown");n(this,"generateInterface",()=>{this.generateCanvas(),this.generatePanel()});n(this,"generateCanvas",()=>{this.canvasParent.innerHTML=`
      ${this.canvasParent.innerHTML}
      <canvas id="${this.canvasId}" class="border-4 border-black cursor-grab"></canvas>
    `});n(this,"generatePanel",()=>{this.panelParent.innerHTML=`
      ${this.panelParent.innerHTML}
      <form id="${this.panelId}" class="w-96">
        <div class="flex justify-between">
          <p>frequency: </p>
          <input type="range" min="1" max="50" value="1">
        </div>
        <div class="flex justify-between">
          <p>Base: </p>
          <select>
            ${["icosahedron","cube","tetrahedron"].map((e,t)=>`<option key=${t} value="${e}">${e}</option>`)}
          </select>
        </div>
        <input class="cursor-pointer" type="submit" value="Generate">
      </form>
    `});n(this,"generateEventListeners",(e,t)=>{const s=document.querySelector(`#${this.canvasId}`);document.addEventListener("mouseup",()=>{this.mouseIsDown=!1}),s.addEventListener("mousedown",()=>{this.mouseIsDown=!0}),s.addEventListener("mousemove",o=>{this.mouseIsDown&&e(o.movementX,o.movementY)}),s.addEventListener("wheel",o=>{o.stopPropagation(),o.preventDefault(),t(o.deltaY<0)})});n(this,"getCanvasElement",()=>document.querySelector(`#${this.canvasId}`));this.canvasParent=e,this.panelParent=t,this.canvasId="geodesic-canvas",this.panelId="geodesic-panel",this.mouseIsDown=!1,this.generateInterface()}}class j{constructor(e,t,s,o={edges:[],faces:[]}){n(this,"x");n(this,"y");n(this,"z");n(this,"connections");this.x=e,this.y=t,this.z=s,this.connections=o}}class H{constructor(e,t){n(this,"geodesicInterface");n(this,"drawCanvas");n(this,"utils");n(this,"bases");n(this,"baseType");n(this,"nodes");n(this,"zoom");n(this,"zoomMin");n(this,"zoomStep");n(this,"zoomMax");n(this,"frequency");n(this,"rotationRads");n(this,"drawOptions");n(this,"drawStyles");n(this,"generateBases",()=>{this.bases.set("cube",this.generateCubeBase()),this.bases.set("icosahedron",this.generateIcosahedronBase())});n(this,"generateIcosahedronBase",()=>{const e=new Map,t=(1+Math.sqrt(5))/4,s=.5,o=this.utils.distanceF(0,.5,t,0,0,0),a=(c,r,i,d)=>{e.set(this.utils.mapChar(d),new j(c*this.zoom,r*this.zoom,i*this.zoom,this.getIcosahedronConnections(d)))};for(let c=0;c<=3;c++){const r=t*(2*Math.floor(c/2)-1),i=s*(2*(c%2)-1);a(0,r/o,i/o,c)}for(let c=4;c<=7;c++){const r=t*(2*Math.floor(c%4/2)-1),i=s*(2*(c%2)-1);a(r/o,i/o,0,c)}for(let c=8;c<=11;c++){const r=s*(2*(c%2)-1),i=t*(2*Math.floor(c%4/2)-1);a(r/o,0,i/o,c)}return e});n(this,"generateCubeBase",()=>{const e=new Map,t=Math.sqrt(3);for(let s=-1;s<2;s+=2)for(let o=-1;o<2;o+=2)for(let a=-1;a<2;a+=2)e.set(this.utils.mapChar(e.size),new j(s/t*this.zoom,o/t*this.zoom,a/t*this.zoom,this.getCubeConnections(e.size)));return e});n(this,"getIcosahedronConnections",e=>{const t=r=>(r^1)%12,s=r=>4*((Math.floor(r/4)+1)%3)+Math.floor(r/2)%2,o=r=>4*((Math.floor(r/4)+2)%3)+2*(r%2);this.utils.mapToChars([e,t(e),s(e)]).sort().join("");const a=this.utils.mapToChars([t(e),s(e),o(e),o(e)+1,s(e)+2]),c=this.utils.calculateConnectedFaces(this.utils.mapChar(e),a,3);return{edges:a,baseEdges:a,faces:c,baseFaces:c}});n(this,"getCubeConnections",e=>({edges:this.utils.mapToChars([e^1,e^2,e^4]),faces:[]}));n(this,"setBase",e=>{this.baseType=e,this.generateGeo()});n(this,"generateGeo",()=>{if(this.frequency===1){this.nodes=this.bases.get(this.baseType);return}switch(this.baseType){case"icosahedron":this.generateIcosahedronAtFrequency();break}});n(this,"generateIcosahedronAtFrequency",()=>{this.nodes=new Map;const e=this.bases.get(this.baseType),t=this.frequency;for(const a of e.keys()){const{x:c,y:r,z:i,connections:d}=e.get(a),l={edges:[],faces:[]};l.baseEdges=d.baseEdges,l.baseFaces=d.baseFaces;for(const b of d.baseEdges)l.edges.push([a+(t-1),b+1].sort().join(""));l.faces=this.utils.calculateConnectedFaces(a,l.edges,3),this.nodes.set(a,new j(c,r,i,l))}const s=new Set;for(const a of e.keys()){const{connections:{baseEdges:c}}=e.get(a);for(const r of c){const i=[a,r].sort();if(!s.has(i.join(""))){for(let d=1;d<t;d++){const l=t-d,b=i[0]+d+i[1]+l,g={edges:new Array(6),faces:[]};g.edges[0]=this.utils.generateEdgeKey(i,d+1,l-1,t),g.edges[3]=this.utils.generateEdgeKey(i,d-1,l+1,t);const{x:f,y:C,z:w}=e.get(i[0]),{x:F,y:B,z:P}=e.get(i[1]),{x:N,y:S,z:x}=this.utils.icosahedronIntermediateNode(d,l,0,f,C,w,F,B,P,0,0,0);this.nodes.set(b,new j(N*this.zoom,S*this.zoom,x*this.zoom,g))}s.add(i.join(""))}}}const o=new Set;for(const a of e.keys()){const{connections:{baseFaces:c}}=e.get(a);for(const r of c){const i=r.split("-").sort();if(!o.has(i.join("-"))){for(let d=1;d<t;d++)for(let l=1;l<t-d;l++){const b=t-d-l,g={edges:[],faces:[]},f=this.utils.generateKeyName(i,d,l,b,t);for(let m=0;m<3;m++)for(let z=0;z<2;z++){const h=d+(m-1),u=l+((m+1+z)%3-1),p=t-h-u,y=this.utils.generateKeyName(i,h,u,p,t);if(g.edges.push(y),h&&u&&p)continue;const k=(h||u)===(h?d:l)?1:2,T=this.nodes.get(y).connections.edges,v=T[k]?6-k:k;if(T[v]=f,(h||u)===1||(h||u)===t-1){const K=h?h>1?h:0:1,A=u?u>1?u:0:1,D=p?p>1?p:0:1,O=this.utils.generateKeyName(i,K,A,D,t),W=v===k?3-k:9-v;T[W]=O}}[g.edges[3],g.edges[5]]=[g.edges[5],g.edges[3]],g.faces=this.utils.calculateConnectedFaces(f,g.edges,3);const{x:C,y:w,z:F}=e.get(i[0]),{x:B,y:P,z:N}=e.get(i[1]),{x:S,y:x,z:M}=e.get(i[2]),{x:I,y:Z,z:$}=this.utils.icosahedronIntermediateNode(d,l,b,C,w,F,B,P,N,S,x,M);this.nodes.set(f,new j(I*this.zoom,Z*this.zoom,$*this.zoom,g))}for(let d=0;d<3;d++){const l=[`${i[d]}${t-1}`,`${i[(d+1)%3]}1`].sort().join(""),b=[`${i[d]}${t-1}`,`${i[(d+2)%3]}1`].sort().join("");this.nodes.get(l).connections.edges.push(b),this.nodes.get(b).connections.edges.push(l)}o.add(i.join("-"))}}}console.log(this.nodes)});n(this,"render",()=>{this.drawCanvas.draw(this.nodes,this.drawOptions,this.drawStyles)});n(this,"updateZoom",e=>{let t=0;if(!e&&this.zoom>this.zoomMin&&(t=this.zoom-this.zoomStep),e&&this.zoom<this.zoomMax&&(t=this.zoom+this.zoomStep),!t)return;const s=this.zoom/t;this.nodes.forEach((o,a)=>{this.nodes.set(a,new j(o.x/s,o.y/s,o.z/s,o.connections))}),this.zoom=t,this.render()});n(this,"rotate",(e,t)=>{this.nodes.forEach((s,o)=>{const{x:a,y:c,z:r}=this.utils.calculateRotatedCoordinates(s.x,s.y,s.z,e,t,0,this.rotationRads);this.nodes.set(o,new j(a,c,r,s.connections))}),this.render()});this.drawOptions={nodes:2,edges:2,faces:0,baseNodes:2,baseEdges:2,baseFaces:0},this.drawStyles={nodeColor:"blue",backNodeColor:"#FFC7C7",nodeSize:2,edgeColor:"black",backEdgeColor:"#D8D8D8",edgeWidth:1,faceColor:"#0800FF7a",faceEdgeColor:"black",backFaceColor:"#C6C6C6",backFaceEdgeColor:"#C6C6C6",baseNodeColor:"red",backBaseNodeColor:"#C6C6C6",baseNodeSize:6,baseEdgeColor:"red",backBaseEdgeColor:"#FF000030",baseEdgeWidth:3,baseFaceColor:"#0800FF7a",baseFaceEdgeColor:"black",backBaseFaceColor:"#868686",backBaseFaceEdgeColor:"#868686"},this.baseType="icosahedron",this.nodes=new Map,this.zoom=475,this.zoomMin=50,this.zoomStep=20,this.zoomMax=1e3,this.bases=new Map,this.frequency=4,this.rotationRads=.002,this.utils=new q,this.geodesicInterface=new R(e,t),this.drawCanvas=new X(this.geodesicInterface.getCanvasElement(),1e3,1e3),this.geodesicInterface.generateEventListeners(this.rotate,this.updateZoom),this.generateBases(),this.generateGeo();const s=Math.random()*1e3+100,o=Math.random()*1e3+100;this.rotate(s,o)}}const L=document.querySelector("#app");new H(L,L);
