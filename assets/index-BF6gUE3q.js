var S=Object.defineProperty;var P=(m,t,e)=>t in m?S(m,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):m[t]=e;var n=(m,t,e)=>P(m,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const i of o)if(i.type==="childList")for(const r of i.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function e(o){const i={};return o.integrity&&(i.integrity=o.integrity),o.referrerPolicy&&(i.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?i.credentials="include":o.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(o){if(o.ep)return;o.ep=!0;const i=e(o);fetch(o.href,i)}})();class C{constructor(){n(this,"distanceF",(t,e,s,o,i,r)=>Math.sqrt((o-t)**2+(i-e)**2+(r-s)**2));n(this,"numFromChar",t=>t.charCodeAt(0)-97);n(this,"mapChar",t=>String.fromCharCode(t+97));n(this,"averageZ",(t,e)=>(t+e)/2);n(this,"mapToChars",t=>t.map(e=>this.mapChar(e)));n(this,"calculateRotatedCoordinates",(t,e,s,o,i,r,c)=>{const a=Math.sin(c*o),h=Math.cos(c*o),l=-Math.sin(c*i),u=Math.cos(c*i),f=Math.sin(c*r),d=Math.cos(c*r),g=t*d*h+e*d*a*l-e*f*u+s*d*a*u+s*f*l,p=t*f*h+e*f*a*l+e*d*u+s*f*a*u-s*d*l,x=-t*a+e*h*l+s*h*u;return{x:g,y:p,z:x}});n(this,"icosahedronIntermediateNode",(t,e,s,o,i,r,c,a,h,l,u,f)=>{const d=t+e+s,g=o*(t/d)+c*(e/d)+l*(s/d),p=i*(t/d)+a*(e/d)+u*(s/d),x=r*(t/d)+h*(e/d)+f*(s/d),y=this.distanceF(g,p,x,0,0,0);return{x:g/y,y:p/y,z:x/y}})}}class E{constructor(t,e,s){n(this,"utils");n(this,"ctx");n(this,"width");n(this,"height");n(this,"centerX");n(this,"centerY");n(this,"clearCanvas",()=>{this.ctx&&(this.ctx.fillStyle="white",this.ctx.fillRect(0,0,this.width,this.height))});n(this,"drawNode",(t,e,s,o)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.arc(t,e,s,0,2*Math.PI),this.ctx.strokeStyle="black",this.ctx.lineWidth=1,this.ctx.fillStyle=o,this.ctx.fill())});n(this,"drawEdge",(t,e,s,o,i)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.moveTo(t,e),this.ctx.lineTo(s,o),this.ctx.lineWidth=8,this.ctx.strokeStyle="black",this.ctx.stroke(),this.ctx.lineWidth=6,this.ctx.strokeStyle=i,this.ctx.lineTo(t,e),this.ctx.stroke())});n(this,"drawFace",(t,e)=>{if(this.ctx){this.ctx.beginPath(),this.ctx.strokeStyle="black",this.ctx.fillStyle=e,this.ctx.lineWidth=2,this.ctx.moveTo(t[0][0],t[0][1]);for(let s=1;s<t.length;s++)this.ctx.lineTo(t[s][0],t[s][1]);this.ctx.lineTo(t[0][0],t[0][1]),this.ctx.fill(),this.ctx.stroke()}});n(this,"drawNodes",t=>{const e=[];t.forEach((s,o)=>{if(s.z>=0){e.push(o);return}const i=this.centerX+s.x,r=this.centerY+s.y;this.drawNode(i,r,s.size,"#FFC7C7")});for(let s=0;s<e.length;s++){const o=t.get(e[s]),i=this.centerX+o.x,r=this.centerY+o.y;this.drawNode(i,r,o.size,o.color)}});n(this,"drawEdges",t=>{const e=[],s=[];for(const o of t.keys()){const i=t.get(o),r=i.connections.edges;for(let c=0;c<r.length;c++){if(this.utils.numFromChar(r[c])<this.utils.numFromChar(o))continue;const a=i.x+this.centerX,h=i.y+this.centerY,l=i.z,u=t.get(r[c]).x+this.centerX,f=t.get(r[c]).y+this.centerY,d=t.get(r[c]).z,g=this.utils.averageZ(l,d);g>0?e.push([a,h,u,f]):g===0?s.push([a,h,u,f]):this.drawEdge(a,h,u,f,"#FFFFFF")}}s.push(...e);for(let o=0;o<s.length;o++){const[i,r,c,a]=s[o];this.drawEdge(i,r,c,a,"red")}});n(this,"drawFaces",t=>{const e=new Set;for(const s of t.keys()){const i=t.get(s).connections.faces;for(let r=0;r<i.length;r++){if(e.has(i[r].split("").sort().join("")))continue;const c=[];let a=0;for(const h of i[r]){const l=t.get(h).x+this.centerX,u=t.get(h).y+this.centerY;a+=t.get(h).z,c.push([l,u])}a/3>=0&&this.drawFace(c,"red"),e.add(i[r])}}});t.width=e,t.height=s,this.utils=new C,this.ctx=t.getContext("2d"),this.width=e,this.height=s,this.centerX=e/2,this.centerY=s/2}}class L{constructor(t,e){n(this,"canvasParent");n(this,"panelParent");n(this,"panelId");n(this,"canvasId");n(this,"mouseIsDown");n(this,"generateInterface",()=>{this.generateCanvas(),this.generatePanel()});n(this,"generateCanvas",()=>{this.canvasParent.innerHTML=`
      ${this.canvasParent.innerHTML}
      <canvas id="${this.canvasId}" class="border-4 border-black cursor-grab"></canvas>
    `});n(this,"generatePanel",()=>{this.panelParent.innerHTML=`
      ${this.panelParent.innerHTML}
      <form id="${this.panelId}" class="w-96">
        <div class="flex justify-between">
          <p>frequency: </p>
          <input type="range" min="1" max="50" value="1">
        </div>
        <div class="flex justify-between">
          <p>Base: </p>
          <select>
            ${["icosahedron","cube","tetrahedron"].map((t,e)=>`<option key=${e} value="${t}">${t}</option>`)}
          </select>
        </div>
        <input class="cursor-pointer" type="submit" value="Generate">
      </form>
    `});n(this,"generateEventListeners",(t,e)=>{const s=document.querySelector(`#${this.canvasId}`);document.addEventListener("mouseup",()=>{this.mouseIsDown=!1}),s.addEventListener("mousedown",()=>{this.mouseIsDown=!0}),s.addEventListener("mousemove",o=>{this.mouseIsDown&&t(o.movementX,o.movementY)}),s.addEventListener("wheel",o=>{e(o.deltaY<0)})});n(this,"getCanvasElement",()=>document.querySelector(`#${this.canvasId}`));this.canvasParent=t,this.panelParent=e,this.canvasId="geodesic-canvas",this.panelId="geodesic-panel",this.mouseIsDown=!1,this.generateInterface()}}class w{constructor(t,e,s,o={edges:[],faces:[]}){n(this,"x");n(this,"y");n(this,"z");n(this,"color");n(this,"size");n(this,"connections");this.x=t,this.y=e,this.z=s,this.color="red",this.size=3,this.connections=o}}class k{constructor(t,e){n(this,"geodesicInterface");n(this,"drawCanvas");n(this,"utils");n(this,"bases");n(this,"baseType");n(this,"nodes");n(this,"zoom");n(this,"zoomMin");n(this,"zoomStep");n(this,"zoomMax");n(this,"frequency");n(this,"rotationRads");n(this,"generateBases",()=>{this.bases.set("cube",this.generateCubeBase()),this.bases.set("icosahedron",this.generateIcosahedronBase())});n(this,"generateIcosahedronBase",()=>{const t=new Map,e=(1+Math.sqrt(5))/4,s=.5,o=this.utils.distanceF(0,.5,e,0,0,0),i=(r,c,a,h)=>{t.set(this.utils.mapChar(h),new w(r*this.zoom,c*this.zoom,a*this.zoom,this.getIcosahedronConnections(h)))};for(let r=0;r<=3;r++){const c=e*(2*Math.floor(r/2)-1),a=s*(2*(r%2)-1);i(0,c/o,a/o,r)}for(let r=4;r<=7;r++){const c=e*(2*Math.floor(r%4/2)-1),a=s*(2*(r%2)-1);i(c/o,a/o,0,r)}for(let r=8;r<=11;r++){const c=s*(2*(r%2)-1),a=e*(2*Math.floor(r%4/2)-1);i(c/o,0,a/o,r)}return t});n(this,"generateCubeBase",()=>{const t=new Map,e=Math.sqrt(3);for(let s=-1;s<2;s+=2)for(let o=-1;o<2;o+=2)for(let i=-1;i<2;i+=2)t.set(this.utils.mapChar(t.size),new w(s/e*this.zoom,o/e*this.zoom,i/e*this.zoom,this.getCubeConnections(t.size)));return t});n(this,"getCubeConnections",t=>({edges:this.utils.mapToChars([t^1,t^2,t^4]),faces:[]}));n(this,"getIcosahedronConnections",t=>{const e=i=>(i^1)%12,s=i=>4*((Math.floor(i/4)+1)%3)+Math.floor(i/2)%2,o=i=>4*((Math.floor(i/4)+2)%3)+2*(i%2);return this.utils.mapToChars([t,e(t),s(t)]).sort().join(""),{edges:this.utils.mapToChars([e(t),s(t),s(t)+2,o(t),o(t)+1]),faces:[[e(t),s(t)],[s(t),o(t)],[o(t),o(t)+1],[o(t)+1,s(t)+2],[s(t)+2,e(t)]].map(i=>this.utils.mapToChars([t,...i]).join(""))}});n(this,"setBase",t=>{this.baseType=t,this.generateGeo()});n(this,"generateGeo",()=>{if(this.frequency===1){this.nodes=this.bases.get(this.baseType);return}switch(this.baseType){case"icosahedron":this.generateIcosahedronAtFrequency();break}});n(this,"generateIcosahedronAtFrequency",()=>{const t=this.bases.get(this.baseType),e=this.frequency,s=new Set;for(const o of t.keys()){const r=t.get(o).connections.faces;for(let c=0;c<r.length;c++){const a=r[c].split("").sort();if(!s.has(a.join(""))){for(let h=e;h>=0;h--)for(let l=e-h;l>=0;l--){const u=e-h-l,f=`${h?`${a[0]}${h}`:""}${l?`${a[1]}${l}`:""}${u?`${a[2]}${u}`:""}`;if(this.nodes.has(f))continue;const{x:d,y:g,z:p}=t.get(a[0]),{x,y,z:b}=t.get(a[1]),{x:M,y:I,z:v}=t.get(a[2]),{x:F,y:T,z:$}=this.utils.icosahedronIntermediateNode(h,l,u,d,g,p,x,y,b,M,I,v);this.nodes.set(f,new w(F*this.zoom,T*this.zoom,$*this.zoom))}s.add(a.join(""))}}}console.log(this.nodes)});n(this,"render",()=>{this.drawCanvas.clearCanvas(),this.drawCanvas.drawNodes(this.nodes)});n(this,"updateZoom",t=>{let e=0;if(!t&&this.zoom>this.zoomMin&&(e=this.zoom-this.zoomStep),t&&this.zoom<this.zoomMax&&(e=this.zoom+this.zoomStep),!e)return;const s=this.zoom/e;this.nodes.forEach((o,i)=>{this.nodes.set(i,new w(o.x/s,o.y/s,o.z/s,o.connections))}),this.zoom=e,this.render()});n(this,"rotate",(t,e)=>{this.nodes.forEach((s,o)=>{const{x:i,y:r,z:c}=this.utils.calculateRotatedCoordinates(s.x,s.y,s.z,t,e,0,this.rotationRads);this.nodes.set(o,new w(i,r,c,s.connections))}),this.render()});this.baseType="icosahedron",this.nodes=new Map,this.zoom=300,this.zoomMin=50,this.zoomStep=20,this.zoomMax=5e3,this.bases=new Map,this.frequency=10,this.rotationRads=.008,this.utils=new C,this.geodesicInterface=new L(t,e),this.drawCanvas=new E(this.geodesicInterface.getCanvasElement(),800,800),this.geodesicInterface.generateEventListeners(this.rotate,this.updateZoom),this.generateBases(),this.generateGeo(),this.render()}}const z=document.querySelector("#app");new k(z,z);
