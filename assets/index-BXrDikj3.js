var q=Object.defineProperty;var Z=(m,e,t)=>e in m?q(m,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):m[e]=t;var n=(m,e,t)=>Z(m,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const a of o)if(a.type==="childList")for(const c of a.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&s(c)}).observe(document,{childList:!0,subtree:!0});function t(o){const a={};return o.integrity&&(a.integrity=o.integrity),o.referrerPolicy&&(a.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?a.credentials="include":o.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(o){if(o.ep)return;o.ep=!0;const a=t(o);fetch(o.href,a)}})();class L{constructor(){n(this,"distanceF",(e,t,s,o,a,c)=>Math.sqrt((o-e)**2+(a-t)**2+(c-s)**2));n(this,"generateKeyName",(e,t,s,o,a)=>`${t?`${e[0]}${t%a?t:""}`:""}${s?`${e[1]}${s%a?s:""}`:""}${o?`${e[2]}${o%a?o:""}`:""}`);n(this,"numFromChar",e=>e.charCodeAt(0)-97);n(this,"mapChar",e=>String.fromCharCode(e+97));n(this,"averageZ",(e,t)=>(e+t)/2);n(this,"mapToChars",e=>e.map(t=>this.mapChar(t)));n(this,"calculateRotatedCoordinates",(e,t,s,o,a,c,i)=>{const h=Math.sin(i*o),d=Math.cos(i*o),r=-Math.sin(i*a),l=Math.cos(i*a),g=Math.sin(i*c),f=Math.cos(i*c),u=e*f*d+t*f*h*r-t*g*l+s*f*h*l+s*g*r,x=e*g*d+t*g*h*r+t*f*l+s*g*h*l-s*f*r,p=-e*h+t*d*r+s*d*l;return{x:u,y:x,z:p}});n(this,"icosahedronIntermediateNode",(e,t,s,o,a,c,i,h,d,r,l,g)=>{const f=e+t+s,u=o*(e/f)+i*(t/f)+r*(s/f),x=a*(e/f)+h*(t/f)+l*(s/f),p=c*(e/f)+d*(t/f)+g*(s/f),E=this.distanceF(u,x,p,0,0,0);return{x:u/E,y:x/E,z:p/E}})}}class Y{constructor(e,t,s){n(this,"utils");n(this,"ctx");n(this,"width");n(this,"height");n(this,"centerX");n(this,"centerY");n(this,"clearCanvas",()=>{this.ctx&&(this.ctx.fillStyle="white",this.ctx.fillRect(0,0,this.width,this.height))});n(this,"draw",(e,t,s)=>{this.clearCanvas();const{frontNodes:o,backNodes:a,frontBaseNodes:c,backBaseNodes:i,frontEdges:h,backEdges:d,frontBaseEdges:r,backBaseEdges:l}=this.separate(e);t.baseNodes.length&&t.baseNodes!=="front"&&this.drawNodes(i,s.baseNodeSize,s.backBaseNodeColor),t.nodes.length&&t.nodes!=="front"&&this.drawNodes(a,s.nodeSize,s.backNodeColor),t.edges.length&&t.edges!=="front"&&this.drawEdges(d,s.edgeWidth,s.backEdgeColor),t.baseEdges.length&&t.baseEdges!=="front"&&this.drawEdges(l,s.baseEdgeWidth,s.backBaseEdgeColor),t.baseEdges.length&&t.baseEdges!=="back"&&this.drawEdges(r,s.baseEdgeWidth,s.baseEdgeColor),t.edges.length&&t.edges!=="back"&&this.drawEdges(h,s.edgeWidth,s.edgeColor),t.nodes.length&&t.nodes!=="back"&&this.drawNodes(o,s.nodeSize,s.nodeColor),t.baseNodes.length&&t.baseNodes!=="back"&&this.drawNodes(c,s.baseNodeSize,s.baseNodeColor),this.drawFaces(e)});n(this,"drawNode",(e,t,s,o)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.arc(e,t,s,0,2*Math.PI),this.ctx.fillStyle=o,this.ctx.fill())});n(this,"drawEdge",(e,t,s,o,a,c)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.moveTo(e,t),this.ctx.lineTo(s,o),this.ctx.lineWidth=a,this.ctx.strokeStyle=c,this.ctx.lineTo(e,t),this.ctx.stroke())});n(this,"drawFace",(e,t)=>{if(this.ctx){this.ctx.beginPath(),this.ctx.strokeStyle="black",this.ctx.fillStyle=t,this.ctx.lineWidth=2,this.ctx.moveTo(e[0][0],e[0][1]);for(let s=1;s<e.length;s++)this.ctx.lineTo(e[s][0],e[s][1]);this.ctx.lineTo(e[0][0],e[0][1]),this.ctx.fill(),this.ctx.stroke()}});n(this,"drawNodes",(e,t,s)=>{for(const[o,a]of e)this.drawNode(o,a,t,s)});n(this,"drawEdges",(e,t,s)=>{for(let o=0;o<e.length;o++){const[a,c,i,h]=e[o];this.drawEdge(a,c,i,h,t,s)}});n(this,"separate",e=>{const t=[],s=[],o=[],a=[],c=[],i=[],h=[],d=[],r=[],l=[],g=[],f=[],u=new Set,x=new Set;for(const p of e.keys()){const E=p.length===1,k=e.get(p),{edges:N,baseEdges:C}=k.connections,w=this.centerX+k.x,y=this.centerY+k.y;if(k.z>=0?(t.push([w,y]),E&&o.push([w,y])):(s.push([w,y]),E&&a.push([w,y])),C)for(let b=0;b<C.length;b++){if(x.has([C[b],p].sort().join("")))continue;const I=e.get(C[b]).x+this.centerX,B=e.get(C[b]).y+this.centerY;this.utils.averageZ(k.z,e.get(C[b]).z)>=0?h.push([w,y,I,B]):d.push([w,y,I,B]),x.add([C[b],p].sort().join(""))}for(let b=0;b<N.length;b++){if(u.has([N[b],p].sort().join("")))continue;const I=e.get(N[b]).x+this.centerX,B=e.get(N[b]).y+this.centerY;this.utils.averageZ(k.z,e.get(N[b]).z)>=0?c.push([w,y,I,B]):i.push([w,y,I,B]),u.add([N[b],p].sort().join(""))}}return{frontNodes:t,backNodes:s,frontBaseNodes:o,backBaseNodes:a,frontEdges:c,backEdges:i,frontBaseEdges:h,backBaseEdges:d,frontFaces:r,backFaces:l,frontBaseFaces:g,backBaseFaces:f}});n(this,"separateFaces",(e,t=!1)=>{const s=new Set,o=[],a=[];for(const c of e.keys()){const i=t?e.get(c).connections.baseFaces:e.get(c).connections.faces;for(let h=0;h<i.length;h++){if(s.has(i[h].split("").sort().join("")))continue;const d=[];let r=0;for(const l of i[h]){const g=e.get(l).x+this.centerX,f=e.get(l).y+this.centerY;r+=e.get(l).z,d.push([g,f])}r/3<0?this.drawFace(d,"#ff0101aa"):a.push(d),s.add(i[h].split("").sort().join(""))}}return{frontFaces:o,backFaces:a}});n(this,"drawFaces",e=>{const t=new Set,s=[];for(const o of e.keys()){const a=e.get(o).connections.faces;for(let c=0;c<a.length;c++){if(t.has(a[c].split("").sort().join("")))continue;const i=[];let h=0;for(const d of a[c]){const r=e.get(d).x+this.centerX,l=e.get(d).y+this.centerY;h+=e.get(d).z,i.push([r,l])}h/3<0?this.drawFace(i,"#ff0101aa"):s.push(i),t.add(a[c].split("").sort().join(""))}}for(const o of s)this.drawFace(o,"#ff0101aa")});e.width=t,e.height=s,this.utils=new L,this.ctx=e.getContext("2d"),this.width=t,this.height=s,this.centerX=t/2,this.centerY=s/2}}class X{constructor(e,t){n(this,"canvasParent");n(this,"panelParent");n(this,"panelId");n(this,"canvasId");n(this,"mouseIsDown");n(this,"generateInterface",()=>{this.generateCanvas(),this.generatePanel()});n(this,"generateCanvas",()=>{this.canvasParent.innerHTML=`
      ${this.canvasParent.innerHTML}
      <canvas id="${this.canvasId}" class="border-4 border-black cursor-grab"></canvas>
    `});n(this,"generatePanel",()=>{this.panelParent.innerHTML=`
      ${this.panelParent.innerHTML}
      <form id="${this.panelId}" class="w-96">
        <div class="flex justify-between">
          <p>frequency: </p>
          <input type="range" min="1" max="50" value="1">
        </div>
        <div class="flex justify-between">
          <p>Base: </p>
          <select>
            ${["icosahedron","cube","tetrahedron"].map((e,t)=>`<option key=${t} value="${e}">${e}</option>`)}
          </select>
        </div>
        <input class="cursor-pointer" type="submit" value="Generate">
      </form>
    `});n(this,"generateEventListeners",(e,t)=>{const s=document.querySelector(`#${this.canvasId}`);document.addEventListener("mouseup",()=>{this.mouseIsDown=!1}),s.addEventListener("mousedown",()=>{this.mouseIsDown=!0}),s.addEventListener("mousemove",o=>{this.mouseIsDown&&e(o.movementX,o.movementY)}),s.addEventListener("wheel",o=>{o.stopPropagation(),o.preventDefault(),t(o.deltaY<0)})});n(this,"getCanvasElement",()=>document.querySelector(`#${this.canvasId}`));this.canvasParent=e,this.panelParent=t,this.canvasId="geodesic-canvas",this.panelId="geodesic-panel",this.mouseIsDown=!1,this.generateInterface()}}class T{constructor(e,t,s,o={edges:[],faces:[]}){n(this,"x");n(this,"y");n(this,"z");n(this,"connections");this.x=e,this.y=t,this.z=s,this.connections=o}}class D{constructor(e,t){n(this,"geodesicInterface");n(this,"drawCanvas");n(this,"utils");n(this,"bases");n(this,"baseType");n(this,"nodes");n(this,"zoom");n(this,"zoomMin");n(this,"zoomStep");n(this,"zoomMax");n(this,"frequency");n(this,"rotationRads");n(this,"drawOptions");n(this,"drawStyles");n(this,"generateBases",()=>{this.bases.set("cube",this.generateCubeBase()),this.bases.set("icosahedron",this.generateIcosahedronBase())});n(this,"generateIcosahedronBase",()=>{const e=new Map,t=(1+Math.sqrt(5))/4,s=.5,o=this.utils.distanceF(0,.5,t,0,0,0),a=(c,i,h,d)=>{e.set(this.utils.mapChar(d),new T(c*this.zoom,i*this.zoom,h*this.zoom,this.getIcosahedronConnections(d)))};for(let c=0;c<=3;c++){const i=t*(2*Math.floor(c/2)-1),h=s*(2*(c%2)-1);a(0,i/o,h/o,c)}for(let c=4;c<=7;c++){const i=t*(2*Math.floor(c%4/2)-1),h=s*(2*(c%2)-1);a(i/o,h/o,0,c)}for(let c=8;c<=11;c++){const i=s*(2*(c%2)-1),h=t*(2*Math.floor(c%4/2)-1);a(i/o,0,h/o,c)}return e});n(this,"generateCubeBase",()=>{const e=new Map,t=Math.sqrt(3);for(let s=-1;s<2;s+=2)for(let o=-1;o<2;o+=2)for(let a=-1;a<2;a+=2)e.set(this.utils.mapChar(e.size),new T(s/t*this.zoom,o/t*this.zoom,a/t*this.zoom,this.getCubeConnections(e.size)));return e});n(this,"getIcosahedronConnections",e=>{const t=i=>(i^1)%12,s=i=>4*((Math.floor(i/4)+1)%3)+Math.floor(i/2)%2,o=i=>4*((Math.floor(i/4)+2)%3)+2*(i%2);this.utils.mapToChars([e,t(e),s(e)]).sort().join("");const a=this.utils.mapToChars([t(e),s(e),s(e)+2,o(e),o(e)+1]),c=[[t(e),s(e)],[s(e),o(e)],[o(e),o(e)+1],[o(e)+1,s(e)+2],[s(e)+2,t(e)]].map(i=>this.utils.mapToChars([e,...i]).join(""));return{edges:a,baseEdges:a,faces:c,baseFaces:c}});n(this,"getCubeConnections",e=>({edges:this.utils.mapToChars([e^1,e^2,e^4]),faces:[]}));n(this,"setBase",e=>{this.baseType=e,this.generateGeo()});n(this,"generateGeo",()=>{if(this.frequency===1){this.nodes=this.bases.get(this.baseType);return}switch(this.baseType){case"icosahedron":this.generateIcosahedronAtFrequency();break}});n(this,"generateIcosahedronAtFrequency",()=>{this.nodes=new Map;const e=this.bases.get(this.baseType),t=this.frequency,s=new Set,o={};for(const a of e.keys()){const i=e.get(a).connections.faces;for(let h=0;h<i.length;h++){const d=i[h].split("").sort();if(!s.has(d.join(""))){for(let r=t;r>=0;r--)for(let l=t-r;l>=0;l--){const g={edges:[],faces:[]},f=t-r-l,u=this.utils.generateKeyName(d,r,l,f,t);if(e.has(u)&&(g.baseEdges=e.get(u).connections.baseEdges,g.baseFaces=e.get(u).connections.baseFaces),r&&l&&f)for(let M=0;M<3;M++)for(let F=0;F<2;F++){const S=r+(M-1),v=l+((M+1+F)%3-1),$=t-S-v,z=this.utils.generateKeyName(d,S,v,$,t);g.edges.push(z),!(S&&v&&$)&&(o[z]?o[z].push(u):o[z]=[u])}else if(r&&l||l&&f||f&&r)for(let M=0;M<2;M++){const F=M*2-1,S=r?r+F:0,v=l?l+(r?-F:F):0,$=f?f-F:0,z=this.utils.generateKeyName(d,S,v,$,t);g.edges.push(z),(S===t||v===t||$===t)&&(o[z]?o[z].push(u):o[z]=[u])}if(this.nodes.has(u))continue;const{x,y:p,z:E}=e.get(d[0]),{x:k,y:N,z:C}=e.get(d[1]),{x:w,y,z:b}=e.get(d[2]),{x:I,y:B,z:j}=this.utils.icosahedronIntermediateNode(r,l,f,x,p,E,k,N,C,w,y,b);this.nodes.set(u,new T(I*this.zoom,B*this.zoom,j*this.zoom,g))}for(let r=0;r<3;r++){const l=[`${d[r]}${t-1}`,`${d[(r+1)%3]}1`].sort().join(""),g=[`${d[r]}${t-1}`,`${d[(r+2)%3]}1`].sort().join("");o[l]?o[l].push(g):o[l]=[g],o[g]?o[g].push(l):o[g]=[l]}s.add(d.join(""))}}}for(const a of Object.keys(o))this.nodes.get(a).connections.edges.push(...o[a])});n(this,"render",()=>{this.drawCanvas.draw(this.nodes,this.drawOptions,this.drawStyles)});n(this,"updateZoom",e=>{let t=0;if(!e&&this.zoom>this.zoomMin&&(t=this.zoom-this.zoomStep),e&&this.zoom<this.zoomMax&&(t=this.zoom+this.zoomStep),!t)return;const s=this.zoom/t;this.nodes.forEach((o,a)=>{this.nodes.set(a,new T(o.x/s,o.y/s,o.z/s,o.connections))}),this.zoom=t,this.render()});n(this,"rotate",(e,t)=>{this.nodes.forEach((s,o)=>{const{x:a,y:c,z:i}=this.utils.calculateRotatedCoordinates(s.x,s.y,s.z,e,t,0,this.rotationRads);this.nodes.set(o,new T(a,c,i,s.connections))}),this.render()});this.drawOptions={nodes:"",edges:"both",faces:"",baseNodes:"both",baseEdges:"both",baseFaces:""},this.drawStyles={nodeColor:"blue",backNodeColor:"#FFC7C7",nodeSize:2,edgeColor:"black",backEdgeColor:"#D8D8D8",edgeWidth:1,faceColor:"blue",backFaceColor:"grey",baseNodeColor:"blue",backBaseNodeColor:"blue",baseNodeSize:4,baseEdgeColor:"red",backBaseEdgeColor:"#ffc7c7",baseEdgeWidth:4,baseFaceColor:"blue",backBaseFaceColor:"grey"},this.baseType="icosahedron",this.nodes=new Map,this.zoom=470,this.zoomMin=50,this.zoomStep=20,this.zoomMax=5e3,this.bases=new Map,this.frequency=10,this.rotationRads=.002,this.utils=new L,this.geodesicInterface=new X(e,t),this.drawCanvas=new Y(this.geodesicInterface.getCanvasElement(),950,950),this.geodesicInterface.generateEventListeners(this.rotate,this.updateZoom),this.generateBases(),this.generateGeo(),this.render()}}const P=document.querySelector("#app");new D(P,P);
