var z=Object.defineProperty;var v=(c,t,e)=>t in c?z(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e;var i=(c,t,e)=>v(c,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))o(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const n of r.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&o(n)}).observe(document,{childList:!0,subtree:!0});function e(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerPolicy&&(r.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?r.credentials="include":s.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function o(s){if(s.ep)return;s.ep=!0;const r=e(s);fetch(s.href,r)}})();class m{constructor(t,e,o,s=[]){i(this,"x");i(this,"y");i(this,"z");i(this,"color");i(this,"size");i(this,"connections");this.x=t,this.y=e,this.z=o,this.color="blue",this.size=8,this.connections=s}}class w{constructor(){i(this,"distanceF",(t,e,o,s,r,n)=>Math.sqrt((s-t)**2+(r-e)**2+(n-o)**2));i(this,"numFromChar",t=>t.charCodeAt(0)-97);i(this,"mapChar",t=>String.fromCharCode(t+97));i(this,"averageZ",(t,e)=>(t+e)/2);i(this,"mapToChars",t=>t.map(e=>this.mapChar(e)));i(this,"calculateRotation",(t,e,o,s,r,n,h,a)=>{const l=Math.sin(r*a),g=Math.cos(r*a),d=Math.sin(n*a),u=Math.cos(n*a),p=Math.sin(h*a),f=Math.cos(h*a),C=t*g*u+e*g*d*p-e*l*f+o*g*d*f+o*l*p,b=t*l*u+e*l*d*p+e*g*f+o*l*d*f-o*g*p,M=-t*d+e*u*p+o*u*f;return new m(C,b,M,s)})}}class S{constructor(t,e,o){i(this,"utils");i(this,"ctx");i(this,"width");i(this,"height");i(this,"centerX");i(this,"centerY");i(this,"clearCanvas",()=>{this.ctx&&(this.ctx.fillStyle="white",this.ctx.fillRect(0,0,this.width,this.height))});i(this,"drawNode",(t,e,o,s)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.arc(t,e,o,0,2*Math.PI),this.ctx.strokeStyle="black",this.ctx.lineWidth=2,this.ctx.fillStyle=s,this.ctx.fill(),this.ctx.stroke())});i(this,"drawEdge",(t,e,o,s)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.moveTo(t,e),this.ctx.lineTo(o,s),this.ctx.lineWidth=8,this.ctx.strokeStyle="black",this.ctx.stroke(),this.ctx.lineWidth=6,this.ctx.strokeStyle="red",this.ctx.lineTo(t,e),this.ctx.stroke())});i(this,"drawNodes",t=>{const e=[];t.forEach((o,s)=>{if(o.z>=0){e.push(s);return}const r=this.centerX+o.x,n=this.centerY+o.y;this.drawNode(r,n,o.size,o.color)});for(let o=0;o<e.length;o++){const s=t.get(e[o]),r=this.centerX+s.x,n=this.centerY+s.y;this.drawNode(r,n,s.size,s.color)}});i(this,"drawEdges2",t=>{const e=[],o=[];for(const s of t.keys()){const r=t.get(s),n=r.connections;for(let h=0;h<n.length;h++){if(this.utils.numFromChar(n[h])<this.utils.numFromChar(s))continue;const a=r.x+this.centerX,l=r.y+this.centerY,g=r.z,d=t.get(n[h]).x+this.centerX,u=t.get(n[h]).y+this.centerY,p=t.get(n[h]).z,f=this.utils.averageZ(g,p);f>0?e.push([a,l,d,u]):f===0?o.push([a,l,d,u]):this.drawEdge(a,l,d,u)}}o.push(...e);for(let s=0;s<o.length;s++){const[r,n,h,a]=o[s];this.drawEdge(r,n,h,a)}});this.utils=new w,this.ctx=t.getContext("2d"),this.width=e,this.height=o,this.centerX=e/2,this.centerY=o/2}}class N{constructor(t,e,o,s){i(this,"drawCanvas");i(this,"utils");i(this,"element");i(this,"bases");i(this,"baseType");i(this,"nodes");i(this,"rotX");i(this,"rotY");i(this,"rotZ");i(this,"zoom");i(this,"step");i(this,"frequency");i(this,"init",()=>{this.generateBases(),this.generateGeo()});i(this,"generateBases",()=>{this.bases.set("cube",this.generateCubeBase()),this.bases.set("icosahedron",this.generateIcosahedronBase())});i(this,"generateIcosahedronBase",()=>{const t=new Map,e=(1+Math.sqrt(5))/4,o=.5,s=this.utils.distanceF(0,.5,e,0,0,0),r=(n,h,a,l)=>{t.set(this.utils.mapChar(l),new m(n,h,a,this.utils.mapToChars(this.getIcosahedronConnections(l))))};for(let n=0;n<=3;n++){const h=e*(2*Math.floor(n/2)-1),a=o*(2*(n%2)-1);r(0,h/s,a/s,n)}for(let n=4;n<=7;n++){const h=e*(2*Math.floor(n%4/2)-1),a=o*(2*(n%2)-1);r(h/s,a/s,0,n)}for(let n=8;n<=11;n++){const h=o*(2*(n%2)-1),a=e*(2*Math.floor(n%4/2)-1);r(h/s,0,a/s,n)}return t});i(this,"generateCubeBase",()=>{const t=new Map,e=Math.sqrt(3);for(let o=-1;o<2;o+=2)for(let s=-1;s<2;s+=2)for(let r=-1;r<2;r+=2)t.set(this.utils.mapChar(t.size),new m(o/e,s/e,r/e,this.utils.mapToChars(this.getCubeConnections(t.size))));return t});i(this,"setZoom",t=>{this.zoom=t,this.render()});i(this,"updateCanvasSize",(t,e)=>{this.element.width=t,this.element.height=e});i(this,"getCubeConnections",t=>[t^1,t^2,t^4]);i(this,"getIcosahedronConnections",t=>{const e=r=>(r^1)%12,o=r=>4*((Math.floor(r/4)+1)%3)+Math.floor(r/2)%2,s=r=>4*((Math.floor(r/4)+2)%3)+2*(r%2);return[e(t),o(t),o(t)+2,s(t),s(t)+1]});i(this,"setBase",t=>{this.baseType=t,this.generateGeo()});i(this,"generateGeo",()=>{this.frequency===1&&(this.nodes=this.bases.get(this.baseType))});i(this,"render",()=>{this.drawCanvas.clearCanvas();const t=new Map;this.nodes.forEach((e,o)=>{t.set(o,this.utils.calculateRotation(e.x*this.zoom,e.y*this.zoom,e.z*this.zoom,e.connections,this.rotX,this.rotY,this.rotZ,this.step))}),this.drawCanvas.drawEdges2(t),this.drawCanvas.drawNodes(t)});i(this,"rotate",(t,e)=>{t==="x"&&(this.rotX+=e?this.step:-this.step),t==="y"&&(this.rotY+=e?this.step:-this.step),t==="z"&&(this.rotZ+=e?this.step:-this.step),this.render()});this.drawCanvas=new S(t,e,o),this.utils=new w,t.width=e,t.height=o,this.element=t,this.baseType="cube",this.nodes=new Map,this.step=Math.PI/12,this.rotX=0,this.rotY=2*this.step,this.rotZ=2*this.step,this.zoom=s,this.bases=new Map,this.frequency=1,this.init()}}const T=c=>{const t="bg-green-100 p-2 font-bold text-2xl text-green-700 w-16 border-4 border-black";return`
    <div id="${c}-nav" class="p-2">
      <button id="${c}-down" data-nav="${c}-down" class="${t} rounded-l-2xl">-${c.toUpperCase()}</button>
      <button id="${c}-up" data-nav="${c}-up" class="${t} rounded-r-2xl">+${c.toUpperCase()}</button>
    </div>
  `};document.querySelector("#app").innerHTML=`
  <canvas id="geodesic-canvas" class="border-4 border-black"></canvas>
  <section id="geodesic-interface" class="flex">
    ${["x","y","z"].map(c=>T(c)).join("")}
  </section>
`;const X=document.querySelector("#geodesic-canvas"),y=new N(X,800,800,300),x=document.querySelectorAll("[data-nav]");for(let c=0;c<x.length;c++)x[c].addEventListener("click",()=>{const[t,e]=x[c].dataset.nav.split("-");y.rotate(t,e==="up")});y.setBase("icosahedron");y.render();
