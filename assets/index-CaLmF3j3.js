var X=Object.defineProperty;var Z=(p,e,t)=>e in p?X(p,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):p[e]=t;var n=(p,e,t)=>Z(p,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))o(s);new MutationObserver(s=>{for(const c of s)if(c.type==="childList")for(const i of c.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&o(i)}).observe(document,{childList:!0,subtree:!0});function t(s){const c={};return s.integrity&&(c.integrity=s.integrity),s.referrerPolicy&&(c.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?c.credentials="include":s.crossOrigin==="anonymous"?c.credentials="omit":c.credentials="same-origin",c}function o(s){if(s.ep)return;s.ep=!0;const c=t(s);fetch(s.href,c)}})();class E{constructor(){n(this,"distanceF",(e,t,o,s,c,i)=>Math.sqrt((s-e)**2+(c-t)**2+(i-o)**2));n(this,"numFromChar",e=>e.charCodeAt(0)-97);n(this,"mapChar",e=>String.fromCharCode(e+97));n(this,"averageZ",(e,t)=>(e+t)/2);n(this,"mapToChars",e=>e.map(t=>this.mapChar(t)));n(this,"calculateRotatedCoordinates",(e,t,o,s,c,i,a)=>{const l=Math.sin(a*s),f=Math.cos(a*s),r=-Math.sin(a*c),h=Math.cos(a*c),u=Math.sin(a*i),d=Math.cos(a*i),g=e*d*f+t*d*l*r-t*u*h+o*d*l*h+o*u*r,m=e*u*f+t*u*l*r+t*d*h+o*u*l*h-o*d*r,y=-e*l+t*f*r+o*f*h;return{x:g,y:m,z:y}});n(this,"icosahedronIntermediateNode",(e,t,o,s,c,i,a,l,f,r,h,u)=>{const d=e+t+o,g=s*(e/d)+a*(t/d)+r*(o/d),m=c*(e/d)+l*(t/d)+h*(o/d),y=i*(e/d)+f*(t/d)+u*(o/d),M=this.distanceF(g,m,y,0,0,0);return{x:g/M,y:m/M,z:y/M}})}}class D{constructor(e,t,o){n(this,"utils");n(this,"ctx");n(this,"width");n(this,"height");n(this,"centerX");n(this,"centerY");n(this,"clearCanvas",()=>{this.ctx&&(this.ctx.fillStyle="white",this.ctx.fillRect(0,0,this.width,this.height))});n(this,"drawNode",(e,t,o,s)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.arc(e,t,o,0,2*Math.PI),this.ctx.strokeStyle="black",this.ctx.lineWidth=1,this.ctx.fillStyle=s,this.ctx.fill())});n(this,"drawEdge",(e,t,o,s,c)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.moveTo(e,t),this.ctx.lineTo(o,s),this.ctx.lineWidth=1,this.ctx.strokeStyle=c,this.ctx.lineTo(e,t),this.ctx.stroke())});n(this,"drawFace",(e,t)=>{if(this.ctx){this.ctx.beginPath(),this.ctx.strokeStyle="black",this.ctx.fillStyle=t,this.ctx.lineWidth=2,this.ctx.moveTo(e[0][0],e[0][1]);for(let o=1;o<e.length;o++)this.ctx.lineTo(e[o][0],e[o][1]);this.ctx.lineTo(e[0][0],e[0][1]),this.ctx.fill(),this.ctx.stroke()}});n(this,"drawNodes",e=>{const t=[];e.forEach((o,s)=>{if(o.z>=0){t.push(s);return}});for(let o=0;o<t.length;o++){const s=e.get(t[o]),c=this.centerX+s.x,i=this.centerY+s.y;this.drawNode(c,i,2,"blue")}});n(this,"drawEdges",(e,t,o=!1)=>{const s=[],c=[];for(const i of e.keys()){const a=e.get(i),l=o?a.connections.baseEdges:a.connections.edges;if(l)for(let f=0;f<l.length;f++){if(this.utils.numFromChar(l[f])<this.utils.numFromChar(i))continue;const r=a.x+this.centerX,h=a.y+this.centerY,u=a.z,d=e.get(l[f]).x+this.centerX,g=e.get(l[f]).y+this.centerY,m=e.get(l[f]).z,y=this.utils.averageZ(u,m);y>0?s.push([r,h,d,g]):y===0?c.push([r,h,d,g]):this.drawEdge(r,h,d,g,"#DDE0FF")}}c.push(...s);for(let i=0;i<c.length;i++){const[a,l,f,r]=c[i];this.drawEdge(a,l,f,r,t)}});n(this,"drawFaces",e=>{const t=new Set;for(const o of e.keys()){const c=e.get(o).connections.faces;for(let i=0;i<c.length;i++){if(t.has(c[i].split("").sort().join("")))continue;const a=[];let l=0;for(const f of c[i]){const r=e.get(f).x+this.centerX,h=e.get(f).y+this.centerY;l+=e.get(f).z,a.push([r,h])}l/3>=0&&this.drawFace(a,"red"),t.add(c[i])}}});e.width=t,e.height=o,this.utils=new E,this.ctx=e.getContext("2d"),this.width=t,this.height=o,this.centerX=t/2,this.centerY=o/2}}class G{constructor(e,t){n(this,"canvasParent");n(this,"panelParent");n(this,"panelId");n(this,"canvasId");n(this,"mouseIsDown");n(this,"generateInterface",()=>{this.generateCanvas(),this.generatePanel()});n(this,"generateCanvas",()=>{this.canvasParent.innerHTML=`
      ${this.canvasParent.innerHTML}
      <canvas id="${this.canvasId}" class="border-4 border-black cursor-grab"></canvas>
    `});n(this,"generatePanel",()=>{this.panelParent.innerHTML=`
      ${this.panelParent.innerHTML}
      <form id="${this.panelId}" class="w-96">
        <div class="flex justify-between">
          <p>frequency: </p>
          <input type="range" min="1" max="50" value="1">
        </div>
        <div class="flex justify-between">
          <p>Base: </p>
          <select>
            ${["icosahedron","cube","tetrahedron"].map((e,t)=>`<option key=${t} value="${e}">${e}</option>`)}
          </select>
        </div>
        <input class="cursor-pointer" type="submit" value="Generate">
      </form>
    `});n(this,"generateEventListeners",(e,t)=>{const o=document.querySelector(`#${this.canvasId}`);document.addEventListener("mouseup",()=>{this.mouseIsDown=!1}),o.addEventListener("mousedown",()=>{this.mouseIsDown=!0}),o.addEventListener("mousemove",s=>{this.mouseIsDown&&e(s.movementX,s.movementY)}),o.addEventListener("wheel",s=>{s.stopPropagation(),s.preventDefault(),t(s.deltaY<0)})});n(this,"getCanvasElement",()=>document.querySelector(`#${this.canvasId}`));this.canvasParent=e,this.panelParent=t,this.canvasId="geodesic-canvas",this.panelId="geodesic-panel",this.mouseIsDown=!1,this.generateInterface()}}class v{constructor(e,t,o,s={edges:[],faces:[]}){n(this,"x");n(this,"y");n(this,"z");n(this,"connections");this.x=e,this.y=t,this.z=o,this.connections=s}}class O{constructor(e,t){n(this,"geodesicInterface");n(this,"drawCanvas");n(this,"utils");n(this,"bases");n(this,"baseType");n(this,"nodes");n(this,"zoom");n(this,"zoomMin");n(this,"zoomStep");n(this,"zoomMax");n(this,"frequency");n(this,"rotationRads");n(this,"generateBases",()=>{this.bases.set("cube",this.generateCubeBase()),this.bases.set("icosahedron",this.generateIcosahedronBase())});n(this,"generateIcosahedronBase",()=>{const e=new Map,t=(1+Math.sqrt(5))/4,o=.5,s=this.utils.distanceF(0,.5,t,0,0,0),c=(i,a,l,f)=>{e.set(this.utils.mapChar(f),new v(i*this.zoom,a*this.zoom,l*this.zoom,this.getIcosahedronConnections(f)))};for(let i=0;i<=3;i++){const a=t*(2*Math.floor(i/2)-1),l=o*(2*(i%2)-1);c(0,a/s,l/s,i)}for(let i=4;i<=7;i++){const a=t*(2*Math.floor(i%4/2)-1),l=o*(2*(i%2)-1);c(a/s,l/s,0,i)}for(let i=8;i<=11;i++){const a=o*(2*(i%2)-1),l=t*(2*Math.floor(i%4/2)-1);c(a/s,0,l/s,i)}return e});n(this,"generateCubeBase",()=>{const e=new Map,t=Math.sqrt(3);for(let o=-1;o<2;o+=2)for(let s=-1;s<2;s+=2)for(let c=-1;c<2;c+=2)e.set(this.utils.mapChar(e.size),new v(o/t*this.zoom,s/t*this.zoom,c/t*this.zoom,this.getCubeConnections(e.size)));return e});n(this,"getIcosahedronConnections",e=>{const t=a=>(a^1)%12,o=a=>4*((Math.floor(a/4)+1)%3)+Math.floor(a/2)%2,s=a=>4*((Math.floor(a/4)+2)%3)+2*(a%2);this.utils.mapToChars([e,t(e),o(e)]).sort().join("");const c=this.utils.mapToChars([t(e),o(e),o(e)+2,s(e),s(e)+1]),i=[[t(e),o(e)],[o(e),s(e)],[s(e),s(e)+1],[s(e)+1,o(e)+2],[o(e)+2,t(e)]].map(a=>this.utils.mapToChars([e,...a]).join(""));return{edges:c,baseEdges:c,faces:i,baseFaces:i}});n(this,"getCubeConnections",e=>({edges:this.utils.mapToChars([e^1,e^2,e^4]),faces:[]}));n(this,"setBase",e=>{this.baseType=e,this.generateGeo()});n(this,"generateGeo",()=>{if(this.frequency===1){this.nodes=this.bases.get(this.baseType);return}switch(this.baseType){case"icosahedron":this.generateIcosahedronAtFrequency();break}});n(this,"generateIcosahedronAtFrequency",()=>{var c;const e=this.bases.get(this.baseType),t=this.frequency,o=new Set,s={};for(const i of e.keys()){const l=e.get(i).connections.faces;for(let f=0;f<l.length;f++){const r=l[f].split("").sort();if(!o.has(r.join(""))){for(let h=t;h>=0;h--)for(let u=t-h;u>=0;u--){const d={edges:[],faces:[]},g=t-h-u,m=`${h?`${r[0]}${h}`:""}${u?`${r[1]}${u}`:""}${g?`${r[2]}${g}`:""}`,y=`${h?`${r[0]}`:""}${u?`${r[1]}`:""}${g?`${r[2]}`:""}`;if(e.has(y)&&(d.baseEdges=(c=e.get(`${y}`).connections.baseEdges)==null?void 0:c.map(x=>x+`${t}`),d.baseFaces=e.get(`${y}`).connections.baseFaces),h&&u&&g)for(let x=0;x<3;x++)for(let $=0;$<2;$++){const z=h+(x-1),b=u+((x+1+$)%3-1),C=t-z-b,w=`${z?`${r[0]}${z}`:""}${b?`${r[1]}${b}`:""}${C?`${r[2]}${C}`:""}`;d.edges.push(w),!(z&&b&&C)&&(s[w]?s[w].push(m):s[w]=[m])}else if(h&&u||u&&g||g&&h)for(let x=0;x<2;x++){const $=x*2-1,z=h?h+$:0,b=u?u+(h?-$:$):0,C=g?g-$:0,w=`${z?`${r[0]}${z}`:""}${b?`${r[1]}${b}`:""}${C?`${r[2]}${C}`:""}`;d.edges.push(w),(z===t||b===t||C===t)&&(s[w]?s[w].push(m):s[w]=[m])}if(this.nodes.has(m))continue;const{x:M,y:T,z:F}=e.get(r[0]),{x:P,y:k,z:S}=e.get(r[1]),{x:L,y:q,z:j}=e.get(r[2]),{x:B,y:N,z:Y}=this.utils.icosahedronIntermediateNode(h,u,g,M,T,F,P,k,S,L,q,j);this.nodes.set(m,new v(B*this.zoom,N*this.zoom,Y*this.zoom,d))}for(let h=0;h<3;h++){const u=[`${r[h]}${t-1}`,`${r[(h+1)%3]}1`].sort().join(""),d=[`${r[h]}${t-1}`,`${r[(h+2)%3]}1`].sort().join("");s[u]?s[u].push(d):s[u]=[d],s[d]?s[d].push(u):s[d]=[u]}o.add(r.join(""))}}}for(const i of Object.keys(s))this.nodes.get(i).connections.edges.push(...s[i])});n(this,"render",()=>{this.drawCanvas.clearCanvas(),this.drawCanvas.drawEdges(this.nodes,"red"),this.drawCanvas.drawNodes(this.nodes)});n(this,"updateZoom",e=>{let t=0;if(!e&&this.zoom>this.zoomMin&&(t=this.zoom-this.zoomStep),e&&this.zoom<this.zoomMax&&(t=this.zoom+this.zoomStep),!t)return;const o=this.zoom/t;this.nodes.forEach((s,c)=>{this.nodes.set(c,new v(s.x/o,s.y/o,s.z/o,s.connections))}),this.zoom=t,this.render()});n(this,"rotate",(e,t)=>{this.nodes.forEach((o,s)=>{const{x:c,y:i,z:a}=this.utils.calculateRotatedCoordinates(o.x,o.y,o.z,e,t,0,this.rotationRads);this.nodes.set(s,new v(c,i,a,o.connections))}),this.render()});this.baseType="icosahedron",this.nodes=new Map,this.zoom=470,this.zoomMin=50,this.zoomStep=20,this.zoomMax=5e3,this.bases=new Map,this.frequency=20,this.rotationRads=.008,this.utils=new E,this.geodesicInterface=new G(e,t),this.drawCanvas=new D(this.geodesicInterface.getCanvasElement(),950,950),this.geodesicInterface.generateEventListeners(this.rotate,this.updateZoom),this.generateBases(),this.generateGeo(),this.render()}}const I=document.querySelector("#app");new O(I,I);
