var X=Object.defineProperty;var Z=(p,e,t)=>e in p?X(p,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):p[e]=t;var o=(p,e,t)=>Z(p,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const c of s)if(c.type==="childList")for(const i of c.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&n(i)}).observe(document,{childList:!0,subtree:!0});function t(s){const c={};return s.integrity&&(c.integrity=s.integrity),s.referrerPolicy&&(c.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?c.credentials="include":s.crossOrigin==="anonymous"?c.credentials="omit":c.credentials="same-origin",c}function n(s){if(s.ep)return;s.ep=!0;const c=t(s);fetch(s.href,c)}})();class E{constructor(){o(this,"distanceF",(e,t,n,s,c,i)=>Math.sqrt((s-e)**2+(c-t)**2+(i-n)**2));o(this,"numFromChar",e=>e.charCodeAt(0)-97);o(this,"mapChar",e=>String.fromCharCode(e+97));o(this,"averageZ",(e,t)=>(e+t)/2);o(this,"mapToChars",e=>e.map(t=>this.mapChar(t)));o(this,"calculateRotatedCoordinates",(e,t,n,s,c,i,r)=>{const l=Math.sin(r*s),f=Math.cos(r*s),a=-Math.sin(r*c),h=Math.cos(r*c),u=Math.sin(r*i),d=Math.cos(r*i),g=e*d*f+t*d*l*a-t*u*h+n*d*l*h+n*u*a,m=e*u*f+t*u*l*a+t*d*h+n*u*l*h-n*d*a,y=-e*l+t*f*a+n*f*h;return{x:g,y:m,z:y}});o(this,"icosahedronIntermediateNode",(e,t,n,s,c,i,r,l,f,a,h,u)=>{const d=e+t+n,g=s*(e/d)+r*(t/d)+a*(n/d),m=c*(e/d)+l*(t/d)+h*(n/d),y=i*(e/d)+f*(t/d)+u*(n/d),M=this.distanceF(g,m,y,0,0,0);return{x:g/M,y:m/M,z:y/M}})}}class D{constructor(e,t,n){o(this,"utils");o(this,"ctx");o(this,"width");o(this,"height");o(this,"centerX");o(this,"centerY");o(this,"clearCanvas",()=>{this.ctx&&(this.ctx.fillStyle="white",this.ctx.fillRect(0,0,this.width,this.height))});o(this,"drawNode",(e,t,n,s)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.arc(e,t,n,0,2*Math.PI),this.ctx.strokeStyle="black",this.ctx.lineWidth=1,this.ctx.fillStyle=s,this.ctx.fill())});o(this,"drawEdge",(e,t,n,s,c)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.moveTo(e,t),this.ctx.lineTo(n,s),this.ctx.lineWidth=1,this.ctx.strokeStyle=c,this.ctx.lineTo(e,t),this.ctx.stroke())});o(this,"drawFace",(e,t)=>{if(this.ctx){this.ctx.beginPath(),this.ctx.strokeStyle="black",this.ctx.fillStyle=t,this.ctx.lineWidth=2,this.ctx.moveTo(e[0][0],e[0][1]);for(let n=1;n<e.length;n++)this.ctx.lineTo(e[n][0],e[n][1]);this.ctx.lineTo(e[0][0],e[0][1]),this.ctx.fill(),this.ctx.stroke()}});o(this,"drawNodes",e=>{const t=[];e.forEach((n,s)=>{if(n.z>=0){t.push(s);return}const c=this.centerX+n.x,i=this.centerY+n.y;this.drawNode(c,i,4,"#FFC7C7")});for(let n=0;n<t.length;n++){const s=e.get(t[n]),c=this.centerX+s.x,i=this.centerY+s.y;this.drawNode(c,i,4,"blue")}});o(this,"drawEdges",(e,t,n=!1)=>{const s=[],c=[];for(const i of e.keys()){const r=e.get(i),l=n?r.connections.baseEdges:r.connections.edges;if(l)for(let f=0;f<l.length;f++){if(this.utils.numFromChar(l[f])<this.utils.numFromChar(i))continue;const a=r.x+this.centerX,h=r.y+this.centerY,u=r.z,d=e.get(l[f]).x+this.centerX,g=e.get(l[f]).y+this.centerY,m=e.get(l[f]).z,y=this.utils.averageZ(u,m);y>0?s.push([a,h,d,g]):y===0?c.push([a,h,d,g]):this.drawEdge(a,h,d,g,"#DDE0FF")}}c.push(...s);for(let i=0;i<c.length;i++){const[r,l,f,a]=c[i];this.drawEdge(r,l,f,a,t)}});o(this,"drawFaces",e=>{const t=new Set;for(const n of e.keys()){const c=e.get(n).connections.faces;for(let i=0;i<c.length;i++){if(t.has(c[i].split("").sort().join("")))continue;const r=[];let l=0;for(const f of c[i]){const a=e.get(f).x+this.centerX,h=e.get(f).y+this.centerY;l+=e.get(f).z,r.push([a,h])}l/3>=0&&this.drawFace(r,"red"),t.add(c[i])}}});e.width=t,e.height=n,this.utils=new E,this.ctx=e.getContext("2d"),this.width=t,this.height=n,this.centerX=t/2,this.centerY=n/2}}class G{constructor(e,t){o(this,"canvasParent");o(this,"panelParent");o(this,"panelId");o(this,"canvasId");o(this,"mouseIsDown");o(this,"generateInterface",()=>{this.generateCanvas(),this.generatePanel()});o(this,"generateCanvas",()=>{this.canvasParent.innerHTML=`
      ${this.canvasParent.innerHTML}
      <canvas id="${this.canvasId}" class="border-4 border-black cursor-grab"></canvas>
    `});o(this,"generatePanel",()=>{this.panelParent.innerHTML=`
      ${this.panelParent.innerHTML}
      <form id="${this.panelId}" class="w-96">
        <div class="flex justify-between">
          <p>frequency: </p>
          <input type="range" min="1" max="50" value="1">
        </div>
        <div class="flex justify-between">
          <p>Base: </p>
          <select>
            ${["icosahedron","cube","tetrahedron"].map((e,t)=>`<option key=${t} value="${e}">${e}</option>`)}
          </select>
        </div>
        <input class="cursor-pointer" type="submit" value="Generate">
      </form>
    `});o(this,"generateEventListeners",(e,t)=>{const n=document.querySelector(`#${this.canvasId}`);document.addEventListener("mouseup",()=>{this.mouseIsDown=!1}),n.addEventListener("mousedown",()=>{this.mouseIsDown=!0}),n.addEventListener("mousemove",s=>{this.mouseIsDown&&e(s.movementX,s.movementY)}),n.addEventListener("wheel",s=>{t(s.deltaY<0)})});o(this,"getCanvasElement",()=>document.querySelector(`#${this.canvasId}`));this.canvasParent=e,this.panelParent=t,this.canvasId="geodesic-canvas",this.panelId="geodesic-panel",this.mouseIsDown=!1,this.generateInterface()}}class I{constructor(e,t,n,s={edges:[],faces:[]}){o(this,"x");o(this,"y");o(this,"z");o(this,"connections");this.x=e,this.y=t,this.z=n,this.connections=s}}class O{constructor(e,t){o(this,"geodesicInterface");o(this,"drawCanvas");o(this,"utils");o(this,"bases");o(this,"baseType");o(this,"nodes");o(this,"zoom");o(this,"zoomMin");o(this,"zoomStep");o(this,"zoomMax");o(this,"frequency");o(this,"rotationRads");o(this,"generateBases",()=>{this.bases.set("cube",this.generateCubeBase()),this.bases.set("icosahedron",this.generateIcosahedronBase())});o(this,"generateIcosahedronBase",()=>{const e=new Map,t=(1+Math.sqrt(5))/4,n=.5,s=this.utils.distanceF(0,.5,t,0,0,0),c=(i,r,l,f)=>{e.set(this.utils.mapChar(f),new I(i*this.zoom,r*this.zoom,l*this.zoom,this.getIcosahedronConnections(f)))};for(let i=0;i<=3;i++){const r=t*(2*Math.floor(i/2)-1),l=n*(2*(i%2)-1);c(0,r/s,l/s,i)}for(let i=4;i<=7;i++){const r=t*(2*Math.floor(i%4/2)-1),l=n*(2*(i%2)-1);c(r/s,l/s,0,i)}for(let i=8;i<=11;i++){const r=n*(2*(i%2)-1),l=t*(2*Math.floor(i%4/2)-1);c(r/s,0,l/s,i)}return e});o(this,"generateCubeBase",()=>{const e=new Map,t=Math.sqrt(3);for(let n=-1;n<2;n+=2)for(let s=-1;s<2;s+=2)for(let c=-1;c<2;c+=2)e.set(this.utils.mapChar(e.size),new I(n/t*this.zoom,s/t*this.zoom,c/t*this.zoom,this.getCubeConnections(e.size)));return e});o(this,"getIcosahedronConnections",e=>{const t=r=>(r^1)%12,n=r=>4*((Math.floor(r/4)+1)%3)+Math.floor(r/2)%2,s=r=>4*((Math.floor(r/4)+2)%3)+2*(r%2);this.utils.mapToChars([e,t(e),n(e)]).sort().join("");const c=this.utils.mapToChars([t(e),n(e),n(e)+2,s(e),s(e)+1]),i=[[t(e),n(e)],[n(e),s(e)],[s(e),s(e)+1],[s(e)+1,n(e)+2],[n(e)+2,t(e)]].map(r=>this.utils.mapToChars([e,...r]).join(""));return{edges:c,baseEdges:c,faces:i,baseFaces:i}});o(this,"getCubeConnections",e=>({edges:this.utils.mapToChars([e^1,e^2,e^4]),faces:[]}));o(this,"setBase",e=>{this.baseType=e,this.generateGeo()});o(this,"generateGeo",()=>{if(this.frequency===1){this.nodes=this.bases.get(this.baseType);return}switch(this.baseType){case"icosahedron":this.generateIcosahedronAtFrequency();break}});o(this,"generateIcosahedronAtFrequency",()=>{var c;const e=this.bases.get(this.baseType),t=this.frequency,n=new Set,s={};for(const i of e.keys()){const l=e.get(i).connections.faces;for(let f=0;f<l.length;f++){const a=l[f].split("").sort();if(!n.has(a.join(""))){for(let h=t;h>=0;h--)for(let u=t-h;u>=0;u--){const d={edges:[],faces:[]},g=t-h-u,m=`${h?`${a[0]}${h}`:""}${u?`${a[1]}${u}`:""}${g?`${a[2]}${g}`:""}`,y=`${h?`${a[0]}`:""}${u?`${a[1]}`:""}${g?`${a[2]}`:""}`;if(e.has(y)&&(d.baseEdges=(c=e.get(`${y}`).connections.baseEdges)==null?void 0:c.map(x=>x+`${t}`),d.baseFaces=e.get(`${y}`).connections.baseFaces),h&&u&&g)for(let x=0;x<3;x++)for(let w=0;w<2;w++){const z=h+(x-1),b=u+((x+1+w)%3-1),C=t-z-b,$=`${z?`${a[0]}${z}`:""}${b?`${a[1]}${b}`:""}${C?`${a[2]}${C}`:""}`;d.edges.push($),!(z&&b&&C)&&(s[$]?s[$].push(m):s[$]=[m])}else if(h&&u||u&&g||g&&h)for(let x=0;x<2;x++){const w=x*2-1,z=h?h+w:0,b=u?u+(h?-w:w):0,C=g?g-w:0,$=`${z?`${a[0]}${z}`:""}${b?`${a[1]}${b}`:""}${C?`${a[2]}${C}`:""}`;d.edges.push($),(z===t||b===t||C===t)&&(s[$]?s[$].push(m):s[$]=[m])}if(this.nodes.has(m))continue;const{x:M,y:T,z:F}=e.get(a[0]),{x:k,y:P,z:S}=e.get(a[1]),{x:L,y:q,z:j}=e.get(a[2]),{x:Y,y:B,z:N}=this.utils.icosahedronIntermediateNode(h,u,g,M,T,F,k,P,S,L,q,j);this.nodes.set(m,new I(Y*this.zoom,B*this.zoom,N*this.zoom,d))}for(let h=0;h<3;h++){const u=[`${a[h]}${t-1}`,`${a[(h+1)%3]}1`].sort().join(""),d=[`${a[h]}${t-1}`,`${a[(h+2)%3]}1`].sort().join("");s[u]?s[u].push(d):s[u]=[d],s[d]?s[d].push(u):s[d]=[u]}n.add(a.join(""))}}}for(const i of Object.keys(s))this.nodes.get(i).connections.edges.push(...s[i])});o(this,"render",()=>{this.drawCanvas.clearCanvas(),this.drawCanvas.drawEdges(this.nodes,"red")});o(this,"updateZoom",e=>{let t=0;if(!e&&this.zoom>this.zoomMin&&(t=this.zoom-this.zoomStep),e&&this.zoom<this.zoomMax&&(t=this.zoom+this.zoomStep),!t)return;const n=this.zoom/t;this.nodes.forEach((s,c)=>{this.nodes.set(c,new I(s.x/n,s.y/n,s.z/n,s.connections))}),this.zoom=t,this.render()});o(this,"rotate",(e,t)=>{this.nodes.forEach((n,s)=>{const{x:c,y:i,z:r}=this.utils.calculateRotatedCoordinates(n.x,n.y,n.z,e,t,0,this.rotationRads);this.nodes.set(s,new I(c,i,r,n.connections))}),this.render()});this.baseType="icosahedron",this.nodes=new Map,this.zoom=380,this.zoomMin=50,this.zoomStep=20,this.zoomMax=5e3,this.bases=new Map,this.frequency=10,this.rotationRads=.008,this.utils=new E,this.geodesicInterface=new G(e,t),this.drawCanvas=new D(this.geodesicInterface.getCanvasElement(),1e3,800),this.geodesicInterface.generateEventListeners(this.rotate,this.updateZoom),this.generateBases(),this.generateGeo(),this.render()}}const v=document.querySelector("#app");new O(v,v);
