var y=Object.defineProperty;var m=(r,t,e)=>t in r?y(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var n=(r,t,e)=>m(r,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const c of o.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&i(c)}).observe(document,{childList:!0,subtree:!0});function e(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function i(s){if(s.ep)return;s.ep=!0;const o=e(s);fetch(s.href,o)}})();class v{constructor(t,e,i){n(this,"ctx");n(this,"width");n(this,"height");n(this,"centerX");n(this,"centerY");n(this,"averageZ",(t,e)=>(t+e)/2);n(this,"clearCanvas",()=>{this.ctx&&(this.ctx.fillStyle="white",this.ctx.fillRect(0,0,this.width,this.height))});n(this,"drawNode",(t,e,i,s)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.arc(t,e,i,0,2*Math.PI),this.ctx.strokeStyle="black",this.ctx.lineWidth=2,this.ctx.fillStyle=s,this.ctx.fill(),this.ctx.stroke())});n(this,"drawEdge",(t,e,i,s)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.moveTo(t,e),this.ctx.lineTo(i,s),this.ctx.lineWidth=8,this.ctx.strokeStyle="black",this.ctx.stroke(),this.ctx.lineWidth=6,this.ctx.strokeStyle="red",this.ctx.lineTo(t,e),this.ctx.stroke())});n(this,"drawNodes",t=>{const e=[];for(let i=0;i<t.length;i++){if(t[i].z>=0){e.push(t[i]);continue}const s=this.centerX+t[i].x,o=this.centerY+t[i].y;this.drawNode(s,o,t[i].size,t[i].color)}for(let i=0;i<e.length;i++){const s=this.centerX+e[i].x,o=this.centerY+e[i].y;this.drawNode(s,o,e[i].size,e[i].color)}});n(this,"drawEdges",t=>{const e=[],i=[];for(let s=0;s<t.length;s++)for(let o=0;o<t[s].connections.length;o++){if(t[s].connections[o]<s)continue;const c=t[s].x+this.centerX,h=t[s].y+this.centerY,a=t[s].z,l=t[t[s].connections[o]].x+this.centerX,d=t[t[s].connections[o]].y+this.centerY,x=t[t[s].connections[o]].z,f=this.averageZ(a,x);f>0?e.push([c,h,l,d]):f===0?i.push([c,h,l,d]):this.drawEdge(c,h,l,d)}for(let s=0;s<i.length;s++){const[o,c,h,a]=i[s];this.drawEdge(o,c,h,a)}for(let s=0;s<e.length;s++){const[o,c,h,a]=e[s];this.drawEdge(o,c,h,a)}});this.ctx=t.getContext("2d"),this.width=e,this.height=i,this.centerX=e/2,this.centerY=i/2}}class u{constructor(t,e,i,s=[]){n(this,"x");n(this,"y");n(this,"z");n(this,"color");n(this,"size");n(this,"connections");this.x=t,this.y=e,this.z=i,this.color="blue",this.size=8,this.connections=s}}class b{constructor(t,e,i){n(this,"drawCanvas");n(this,"element");n(this,"nodes");n(this,"rotX");n(this,"rotY");n(this,"rotZ");n(this,"zoom");n(this,"step");n(this,"generateIcosahedronBase",()=>{const t=(1+Math.sqrt(5))/4;for(let e=-.5;e<=.5;e++)for(let i=-t;i<=t;i+=t*2){const s=e*this.zoom,o=i*this.zoom;this.nodes.push(new u(0,s,o)),this.nodes.push(new u(o,0,s)),this.nodes.push(new u(s,o,0))}});n(this,"generateCubeBase",()=>{for(let t=-1;t<2;t+=2)for(let e=-1;e<2;e+=2)for(let i=-1;i<2;i+=2)this.nodes.push(new u(t*this.zoom,e*this.zoom,i*this.zoom,this.findBinDif(this.nodes.length)))});n(this,"setZoom",t=>this.zoom=t);n(this,"updateCanvasSize",(t,e)=>{this.element.width=t,this.element.height=e});n(this,"findBinDif",t=>[t^1,t^2,t^4]);n(this,"calculateRotation",(t,e,i,s)=>{const o=Math.sin(this.rotX*this.step),c=Math.cos(this.rotX*this.step),h=Math.sin(this.rotY*this.step),a=Math.cos(this.rotY*this.step),l=Math.sin(this.rotZ*this.step),d=Math.cos(this.rotZ*this.step),x=t*c*a+e*c*h*l-e*o*d+i*c*h*d+i*o*l,f=t*o*a+e*o*h*l+e*c*d+i*o*h*d-i*c*l,w=-t*h+e*a*l+i*a*d;return new u(x,f,w,s)});n(this,"render",()=>{this.drawCanvas.clearCanvas();const t=this.nodes.map(e=>this.calculateRotation(e.x,e.y,e.z,e.connections));this.drawCanvas.drawNodes(t)});n(this,"rotate",(t,e)=>{t==="x"&&(this.rotX+=e?this.step:-this.step),t==="y"&&(this.rotY+=e?this.step:-this.step),t==="z"&&(this.rotZ+=e?this.step:-this.step),this.render()});this.drawCanvas=new v(t,e,i),t.width=e,t.height=i,this.element=t,this.nodes=[],this.step=Math.PI/12,this.rotX=0,this.rotY=2*this.step,this.rotZ=2*this.step,this.zoom=1}}const z=r=>{const t="bg-green-100 p-2 font-bold text-2xl text-green-700 w-16 border-4 border-black";return`
    <div id="${r}-nav" class="p-2">
      <button id="${r}-down" data-nav="${r}-down" class="${t} rounded-l-2xl">-${r.toUpperCase()}</button>
      <button id="${r}-up" data-nav="${r}-up" class="${t} rounded-r-2xl">+${r.toUpperCase()}</button>
    </div>
  `};document.querySelector("#app").innerHTML=`
  <canvas id="geodesic-canvas" class="border-4 border-black"></canvas>
  <section id="geodesic-interface" class="flex">
    ${["x","y","z"].map(r=>z(r)).join("")}
  </section>
`;const X=document.querySelector("#geodesic-canvas"),p=new b(X,800,800),g=document.querySelectorAll("[data-nav]");for(let r=0;r<g.length;r++)g[r].addEventListener("click",()=>{const[t,e]=g[r].dataset.nav.split("-");p.rotate(t,e==="up")});p.setZoom(300);p.generateIcosahedronBase();p.render();
