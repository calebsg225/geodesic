var z=Object.defineProperty;var T=(c,t,e)=>t in c?z(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e;var n=(c,t,e)=>T(c,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const i of o)if(i.type==="childList")for(const r of i.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function e(o){const i={};return o.integrity&&(i.integrity=o.integrity),o.referrerPolicy&&(i.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?i.credentials="include":o.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(o){if(o.ep)return;o.ep=!0;const i=e(o);fetch(o.href,i)}})();class m{constructor(t,e,s,o={edges:[],faces:[]}){n(this,"x");n(this,"y");n(this,"z");n(this,"color");n(this,"size");n(this,"connections");this.x=t,this.y=e,this.z=s,this.color="blue",this.size=8,this.connections=o}}class w{constructor(){n(this,"distanceF",(t,e,s,o,i,r)=>Math.sqrt((o-t)**2+(i-e)**2+(r-s)**2));n(this,"numFromChar",t=>t.charCodeAt(0)-97);n(this,"mapChar",t=>String.fromCharCode(t+97));n(this,"averageZ",(t,e)=>(t+e)/2);n(this,"mapToChars",t=>t.map(e=>this.mapChar(e)));n(this,"calculateRotation",(t,e,s,o,i,r,h,a)=>{const l=Math.sin(i*a),u=Math.cos(i*a),d=Math.sin(r*a),f=Math.cos(r*a),p=Math.sin(h*a),g=Math.cos(h*a),b=t*u*f+e*u*d*p-e*l*g+s*u*d*g+s*l*p,C=t*l*f+e*l*d*p+e*u*g+s*l*d*g-s*u*p,M=-t*d+e*f*p+s*f*g;return new m(b,C,M,o)})}}class S{constructor(t,e,s){n(this,"utils");n(this,"ctx");n(this,"width");n(this,"height");n(this,"centerX");n(this,"centerY");n(this,"clearCanvas",()=>{this.ctx&&(this.ctx.fillStyle="white",this.ctx.fillRect(0,0,this.width,this.height))});n(this,"drawNode",(t,e,s,o)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.arc(t,e,s,0,2*Math.PI),this.ctx.strokeStyle="black",this.ctx.lineWidth=2,this.ctx.fillStyle=o,this.ctx.fill(),this.ctx.stroke())});n(this,"drawEdge",(t,e,s,o,i)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.moveTo(t,e),this.ctx.lineTo(s,o),this.ctx.lineWidth=8,this.ctx.strokeStyle="black",this.ctx.stroke(),this.ctx.lineWidth=6,this.ctx.strokeStyle=i,this.ctx.lineTo(t,e),this.ctx.stroke())});n(this,"drawFace",(t,e)=>{if(this.ctx){this.ctx.beginPath(),this.ctx.strokeStyle="black",this.ctx.fillStyle=e,this.ctx.lineWidth=2,this.ctx.moveTo(t[0][0],t[0][1]);for(let s=1;s<t.length;s++)this.ctx.lineTo(t[s][0],t[s][1]);this.ctx.lineTo(t[0][0],t[0][1]),this.ctx.fill(),this.ctx.stroke()}});n(this,"drawNodes",t=>{const e=[];t.forEach((s,o)=>{if(s.z>=0){e.push(o);return}const i=this.centerX+s.x,r=this.centerY+s.y;this.drawNode(i,r,s.size,s.color)});for(let s=0;s<e.length;s++){const o=t.get(e[s]),i=this.centerX+o.x,r=this.centerY+o.y;this.drawNode(i,r,o.size,o.color)}});n(this,"drawEdges",t=>{const e=[],s=[];for(const o of t.keys()){const i=t.get(o),r=i.connections.edges;for(let h=0;h<r.length;h++){if(this.utils.numFromChar(r[h])<this.utils.numFromChar(o))continue;const a=i.x+this.centerX,l=i.y+this.centerY,u=i.z,d=t.get(r[h]).x+this.centerX,f=t.get(r[h]).y+this.centerY,p=t.get(r[h]).z,g=this.utils.averageZ(u,p);g>0?e.push([a,l,d,f]):g===0?s.push([a,l,d,f]):this.drawEdge(a,l,d,f,"#FF877E")}}s.push(...e);for(let o=0;o<s.length;o++){const[i,r,h,a]=s[o];this.drawEdge(i,r,h,a,"red")}});n(this,"drawFaces",t=>{const e=new Set;for(const s of t.keys()){const i=t.get(s).connections.faces;for(let r=0;r<i.length;r++){if(e.has(i[r]))continue;const h=[];let a=0;for(const l of i[r]){const u=t.get(l).x+this.centerX,d=t.get(l).y+this.centerY;a+=t.get(l).z,h.push([u,d])}a/3>=0&&this.drawFace(h,"red"),e.add(i[r])}}});this.utils=new w,this.ctx=t.getContext("2d"),this.width=e,this.height=s,this.centerX=e/2,this.centerY=s/2}}class k{constructor(t,e,s,o){n(this,"drawCanvas");n(this,"utils");n(this,"element");n(this,"bases");n(this,"baseType");n(this,"nodes");n(this,"rotX");n(this,"rotY");n(this,"rotZ");n(this,"zoom");n(this,"step");n(this,"frequency");n(this,"init",()=>{this.generateBases(),this.generateGeo()});n(this,"generateBases",()=>{this.bases.set("cube",this.generateCubeBase()),this.bases.set("icosahedron",this.generateIcosahedronBase())});n(this,"generateIcosahedronBase",()=>{const t=new Map,e=(1+Math.sqrt(5))/4,s=.5,o=this.utils.distanceF(0,.5,e,0,0,0),i=(r,h,a,l)=>{t.set(this.utils.mapChar(l),new m(r,h,a,this.getIcosahedronConnections(l)))};for(let r=0;r<=3;r++){const h=e*(2*Math.floor(r/2)-1),a=s*(2*(r%2)-1);i(0,h/o,a/o,r)}for(let r=4;r<=7;r++){const h=e*(2*Math.floor(r%4/2)-1),a=s*(2*(r%2)-1);i(h/o,a/o,0,r)}for(let r=8;r<=11;r++){const h=s*(2*(r%2)-1),a=e*(2*Math.floor(r%4/2)-1);i(h/o,0,a/o,r)}return t});n(this,"generateCubeBase",()=>{const t=new Map,e=Math.sqrt(3);for(let s=-1;s<2;s+=2)for(let o=-1;o<2;o+=2)for(let i=-1;i<2;i+=2)t.set(this.utils.mapChar(t.size),new m(s/e,o/e,i/e,this.getCubeConnections(t.size)));return t});n(this,"setZoom",t=>{this.zoom=t,this.render()});n(this,"updateCanvasSize",(t,e)=>{this.element.width=t,this.element.height=e});n(this,"getCubeConnections",t=>({edges:this.utils.mapToChars([t^1,t^2,t^4]),faces:[]}));n(this,"getIcosahedronConnections",t=>{const e=i=>(i^1)%12,s=i=>4*((Math.floor(i/4)+1)%3)+Math.floor(i/2)%2,o=i=>4*((Math.floor(i/4)+2)%3)+2*(i%2);return this.utils.mapToChars([t,e(t),s(t)]).sort().join(""),{edges:this.utils.mapToChars([e(t),s(t),s(t)+2,o(t),o(t)+1]),faces:[[e(t),s(t)],[s(t),o(t)],[o(t),o(t)+1],[o(t)+1,s(t)+2],[s(t)+2,e(t)]].map(i=>this.utils.mapToChars([t,...i]).sort().join(""))}});n(this,"setBase",t=>{this.baseType=t,this.generateGeo()});n(this,"generateGeo",()=>{this.frequency===1&&(this.nodes=this.bases.get(this.baseType))});n(this,"render",()=>{this.drawCanvas.clearCanvas();const t=new Map;this.nodes.forEach((e,s)=>{t.set(s,this.utils.calculateRotation(e.x*this.zoom,e.y*this.zoom,e.z*this.zoom,e.connections,this.rotX,this.rotY,this.rotZ,this.step))}),this.drawCanvas.drawFaces(t)});n(this,"rotate",(t,e)=>{t==="x"&&(this.rotX+=e?this.step:-this.step),t==="y"&&(this.rotY+=e?this.step:-this.step),t==="z"&&(this.rotZ+=e?this.step:-this.step),this.render()});this.drawCanvas=new S(t,e,s),this.utils=new w,t.width=e,t.height=s,this.element=t,this.baseType="cube",this.nodes=new Map,this.step=Math.PI/12,this.rotX=0,this.rotY=-2*this.step,this.rotZ=-2*this.step,this.zoom=o,this.bases=new Map,this.frequency=1,this.init()}}const F=c=>{const t="bg-green-100 p-2 font-bold text-2xl text-green-700 w-16 border-4 border-black";return`
    <div id="${c}-nav" class="p-2">
      <button id="${c}-down" data-nav="${c}-down" class="${t} rounded-l-2xl">-${c.toUpperCase()}</button>
      <button id="${c}-up" data-nav="${c}-up" class="${t} rounded-r-2xl">+${c.toUpperCase()}</button>
    </div>
  `};document.querySelector("#app").innerHTML=`
  <canvas id="geodesic-canvas" class="border-4 border-black"></canvas>
  <section id="geodesic-interface" class="flex">
    ${["x","y","z"].map(c=>F(c)).join("")}
  </section>
`;const X=document.querySelector("#geodesic-canvas"),y=new k(X,800,800,300),x=document.querySelectorAll("[data-nav]");for(let c=0;c<x.length;c++)x[c].addEventListener("click",()=>{const[t,e]=x[c].dataset.nav.split("-");y.rotate(t,e==="up")});y.setBase("icosahedron");y.render();
