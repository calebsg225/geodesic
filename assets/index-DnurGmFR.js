var j=Object.defineProperty;var Y=(b,e,t)=>e in b?j(b,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):b[e]=t;var n=(b,e,t)=>Y(b,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))o(s);new MutationObserver(s=>{for(const a of s)if(a.type==="childList")for(const r of a.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&o(r)}).observe(document,{childList:!0,subtree:!0});function t(s){const a={};return s.integrity&&(a.integrity=s.integrity),s.referrerPolicy&&(a.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?a.credentials="include":s.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function o(s){if(s.ep)return;s.ep=!0;const a=t(s);fetch(s.href,a)}})();class I{constructor(){n(this,"distanceF",(e,t,o,s,a,r)=>Math.sqrt((s-e)**2+(a-t)**2+(r-o)**2));n(this,"generateKeyName",(e,t,o,s,a)=>`${t?`${e[0]}${t%a?t:""}`:""}${o?`${e[1]}${o%a?o:""}`:""}${s?`${e[2]}${s%a?s:""}`:""}`);n(this,"numFromChar",e=>e.charCodeAt(0)-97);n(this,"mapChar",e=>String.fromCharCode(e+97));n(this,"averageZ",(e,t)=>(e+t)/2);n(this,"mapToChars",e=>e.map(t=>this.mapChar(t)));n(this,"calculateRotatedCoordinates",(e,t,o,s,a,r,i)=>{const c=Math.sin(i*s),d=Math.cos(i*s),h=-Math.sin(i*a),l=Math.cos(i*a),u=Math.sin(i*r),f=Math.cos(i*r),g=e*f*d+t*f*c*h-t*u*l+o*f*c*l+o*u*h,y=e*u*d+t*u*c*h+t*f*l+o*u*c*l-o*f*h,C=-e*c+t*d*h+o*d*l;return{x:g,y,z:C}});n(this,"icosahedronIntermediateNode",(e,t,o,s,a,r,i,c,d,h,l,u)=>{const f=e+t+o,g=s*(e/f)+i*(t/f)+h*(o/f),y=a*(e/f)+c*(t/f)+l*(o/f),C=r*(e/f)+d*(t/f)+u*(o/f),E=this.distanceF(g,y,C,0,0,0);return{x:g/E,y:y/E,z:C/E}})}}class Z{constructor(e,t,o){n(this,"utils");n(this,"ctx");n(this,"width");n(this,"height");n(this,"centerX");n(this,"centerY");n(this,"clearCanvas",()=>{this.ctx&&(this.ctx.fillStyle="white",this.ctx.fillRect(0,0,this.width,this.height))});n(this,"draw",(e,t,o)=>{this.clearCanvas();const{frontNodes:s,backNodes:a}=t.nodes.length?this.separateNodes(e):{frontNodes:[],backNodes:[]},{frontNodes:r,backNodes:i}=t.baseNodes.length?this.separateNodes(e,!0):{frontNodes:[],backNodes:[]},{frontEdges:c,backEdges:d}=t.edges.length?this.separateEdges(e):{frontEdges:[],backEdges:[]},{frontEdges:h,backEdges:l}=t.baseEdges.length?this.separateEdges(e,!0):{frontEdges:[],backEdges:[]};t.baseNodes!=="front"&&this.drawNodes(i,o.baseNodeSize,o.backBaseNodeColor),t.nodes!=="front"&&this.drawNodes(a,o.nodeSize,o.backNodeColor),t.edges!=="front"&&this.drawEdges(d,o.edgeWidth,o.backEdgeColor),t.baseEdges!=="front"&&this.drawEdges(l,o.baseEdgeWidth,o.backBaseEdgeColor),t.baseEdges!=="back"&&this.drawEdges(h,o.baseEdgeWidth,o.baseEdgeColor),t.edges!=="back"&&this.drawEdges(c,o.edgeWidth,o.edgeColor),t.nodes!=="back"&&this.drawNodes(s,o.nodeSize,o.nodeColor),t.baseNodes!=="back"&&this.drawNodes(r,o.baseNodeSize,o.baseNodeColor)});n(this,"drawNode",(e,t,o,s)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.arc(e,t,o,0,2*Math.PI),this.ctx.fillStyle=s,this.ctx.fill())});n(this,"drawEdge",(e,t,o,s,a,r)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.moveTo(e,t),this.ctx.lineTo(o,s),this.ctx.lineWidth=a,this.ctx.strokeStyle=r,this.ctx.lineTo(e,t),this.ctx.stroke())});n(this,"drawFace",(e,t)=>{if(this.ctx){this.ctx.beginPath(),this.ctx.strokeStyle="black",this.ctx.fillStyle=t,this.ctx.lineWidth=2,this.ctx.moveTo(e[0][0],e[0][1]);for(let o=1;o<e.length;o++)this.ctx.lineTo(e[o][0],e[o][1]);this.ctx.lineTo(e[0][0],e[0][1]),this.ctx.fill(),this.ctx.stroke()}});n(this,"drawNodes",(e,t,o)=>{for(const[s,a]of e)this.drawNode(s,a,t,o)});n(this,"drawEdges",(e,t,o)=>{for(let s=0;s<e.length;s++){const[a,r,i,c]=e[s];this.drawEdge(a,r,i,c,t,o)}});n(this,"separateNodes",(e,t=!1)=>{const o=[],s=[];return e.forEach((a,r)=>{const i=r.length===1;if(t&&!i)return;const c=this.centerX+a.x,d=this.centerY+a.y;a.z>=0?o.push([c,d]):s.push([c,d])}),{frontNodes:o,backNodes:s}});n(this,"separateEdges",(e,t=!1)=>{const o=[],s=[];for(const a of e.keys()){const r=e.get(a),i=t?r.connections.baseEdges:r.connections.edges;if(i)for(let c=0;c<i.length;c++){if(this.utils.numFromChar(i[c])<this.utils.numFromChar(a))continue;const d=r.x+this.centerX,h=r.y+this.centerY,l=r.z,u=e.get(i[c]).x+this.centerX,f=e.get(i[c]).y+this.centerY,g=e.get(i[c]).z;this.utils.averageZ(l,g)>=0?o.push([d,h,u,f]):s.push([d,h,u,f])}}return{frontEdges:o,backEdges:s}});n(this,"drawFaces",e=>{const t=new Set,o=[];for(const s of e.keys()){const r=e.get(s).connections.faces;for(let i=0;i<r.length;i++){if(t.has(r[i].split("").sort().join("")))continue;const c=[];let d=0;for(const h of r[i]){const l=e.get(h).x+this.centerX,u=e.get(h).y+this.centerY;d+=e.get(h).z,c.push([l,u])}d/3<0?this.drawFace(c,"#ff0101aa"):o.push(c),t.add(r[i].split("").sort().join(""))}}for(const s of o)this.drawFace(s,"#ff0101aa")});e.width=t,e.height=o,this.utils=new I,this.ctx=e.getContext("2d"),this.width=t,this.height=o,this.centerX=t/2,this.centerY=o/2}}class D{constructor(e,t){n(this,"canvasParent");n(this,"panelParent");n(this,"panelId");n(this,"canvasId");n(this,"mouseIsDown");n(this,"generateInterface",()=>{this.generateCanvas(),this.generatePanel()});n(this,"generateCanvas",()=>{this.canvasParent.innerHTML=`
      ${this.canvasParent.innerHTML}
      <canvas id="${this.canvasId}" class="border-4 border-black cursor-grab"></canvas>
    `});n(this,"generatePanel",()=>{this.panelParent.innerHTML=`
      ${this.panelParent.innerHTML}
      <form id="${this.panelId}" class="w-96">
        <div class="flex justify-between">
          <p>frequency: </p>
          <input type="range" min="1" max="50" value="1">
        </div>
        <div class="flex justify-between">
          <p>Base: </p>
          <select>
            ${["icosahedron","cube","tetrahedron"].map((e,t)=>`<option key=${t} value="${e}">${e}</option>`)}
          </select>
        </div>
        <input class="cursor-pointer" type="submit" value="Generate">
      </form>
    `});n(this,"generateEventListeners",(e,t)=>{const o=document.querySelector(`#${this.canvasId}`);document.addEventListener("mouseup",()=>{this.mouseIsDown=!1}),o.addEventListener("mousedown",()=>{this.mouseIsDown=!0}),o.addEventListener("mousemove",s=>{this.mouseIsDown&&e(s.movementX,s.movementY)}),o.addEventListener("wheel",s=>{s.stopPropagation(),s.preventDefault(),t(s.deltaY<0)})});n(this,"getCanvasElement",()=>document.querySelector(`#${this.canvasId}`));this.canvasParent=e,this.panelParent=t,this.canvasId="geodesic-canvas",this.panelId="geodesic-panel",this.mouseIsDown=!1,this.generateInterface()}}class k{constructor(e,t,o,s={edges:[],faces:[]}){n(this,"x");n(this,"y");n(this,"z");n(this,"connections");this.x=e,this.y=t,this.z=o,this.connections=s}}class O{constructor(e,t){n(this,"geodesicInterface");n(this,"drawCanvas");n(this,"utils");n(this,"bases");n(this,"baseType");n(this,"nodes");n(this,"zoom");n(this,"zoomMin");n(this,"zoomStep");n(this,"zoomMax");n(this,"frequency");n(this,"rotationRads");n(this,"drawOptions");n(this,"drawStyles");n(this,"generateBases",()=>{this.bases.set("cube",this.generateCubeBase()),this.bases.set("icosahedron",this.generateIcosahedronBase())});n(this,"generateIcosahedronBase",()=>{const e=new Map,t=(1+Math.sqrt(5))/4,o=.5,s=this.utils.distanceF(0,.5,t,0,0,0),a=(r,i,c,d)=>{e.set(this.utils.mapChar(d),new k(r*this.zoom,i*this.zoom,c*this.zoom,this.getIcosahedronConnections(d)))};for(let r=0;r<=3;r++){const i=t*(2*Math.floor(r/2)-1),c=o*(2*(r%2)-1);a(0,i/s,c/s,r)}for(let r=4;r<=7;r++){const i=t*(2*Math.floor(r%4/2)-1),c=o*(2*(r%2)-1);a(i/s,c/s,0,r)}for(let r=8;r<=11;r++){const i=o*(2*(r%2)-1),c=t*(2*Math.floor(r%4/2)-1);a(i/s,0,c/s,r)}return e});n(this,"generateCubeBase",()=>{const e=new Map,t=Math.sqrt(3);for(let o=-1;o<2;o+=2)for(let s=-1;s<2;s+=2)for(let a=-1;a<2;a+=2)e.set(this.utils.mapChar(e.size),new k(o/t*this.zoom,s/t*this.zoom,a/t*this.zoom,this.getCubeConnections(e.size)));return e});n(this,"getIcosahedronConnections",e=>{const t=i=>(i^1)%12,o=i=>4*((Math.floor(i/4)+1)%3)+Math.floor(i/2)%2,s=i=>4*((Math.floor(i/4)+2)%3)+2*(i%2);this.utils.mapToChars([e,t(e),o(e)]).sort().join("");const a=this.utils.mapToChars([t(e),o(e),o(e)+2,s(e),s(e)+1]),r=[[t(e),o(e)],[o(e),s(e)],[s(e),s(e)+1],[s(e)+1,o(e)+2],[o(e)+2,t(e)]].map(i=>this.utils.mapToChars([e,...i]).join(""));return{edges:a,baseEdges:a,faces:r,baseFaces:r}});n(this,"getCubeConnections",e=>({edges:this.utils.mapToChars([e^1,e^2,e^4]),faces:[]}));n(this,"setBase",e=>{this.baseType=e,this.generateGeo()});n(this,"generateGeo",()=>{if(this.frequency===1){this.nodes=this.bases.get(this.baseType);return}switch(this.baseType){case"icosahedron":this.generateIcosahedronAtFrequency();break}});n(this,"generateIcosahedronAtFrequency",()=>{this.nodes=new Map;const e=this.bases.get(this.baseType),t=this.frequency,o=new Set,s={};for(const a of e.keys()){const i=e.get(a).connections.faces;for(let c=0;c<i.length;c++){const d=i[c].split("").sort();if(!o.has(d.join(""))){for(let h=t;h>=0;h--)for(let l=t-h;l>=0;l--){const u={edges:[],faces:[]},f=t-h-l,g=this.utils.generateKeyName(d,h,l,f,t);if(e.has(g)&&(u.baseEdges=e.get(`${g}`).connections.baseEdges,u.baseFaces=e.get(`${g}`).connections.baseFaces),h&&l&&f)for(let p=0;p<3;p++)for(let w=0;w<2;w++){const x=h+(p-1),z=l+((p+1+w)%3-1),N=t-x-z,m=this.utils.generateKeyName(d,x,z,N,t);u.edges.push(m),!(x&&z&&N)&&(s[m]?s[m].push(g):s[m]=[g])}else if(h&&l||l&&f||f&&h)for(let p=0;p<2;p++){const w=p*2-1,x=h?h+w:0,z=l?l+(h?-w:w):0,N=f?f-w:0,m=this.utils.generateKeyName(d,x,z,N,t);u.edges.push(m),(x===t||z===t||N===t)&&(s[m]?s[m].push(g):s[m]=[g])}if(this.nodes.has(g))continue;const{x:y,y:C,z:E}=e.get(d[0]),{x:$,y:v,z:S}=e.get(d[1]),{x:F,y:T,z:B}=e.get(d[2]),{x:P,y:L,z:q}=this.utils.icosahedronIntermediateNode(h,l,f,y,C,E,$,v,S,F,T,B);this.nodes.set(g,new k(P*this.zoom,L*this.zoom,q*this.zoom,u))}for(let h=0;h<3;h++){const l=[`${d[h]}${t-1}`,`${d[(h+1)%3]}1`].sort().join(""),u=[`${d[h]}${t-1}`,`${d[(h+2)%3]}1`].sort().join("");s[l]?s[l].push(u):s[l]=[u],s[u]?s[u].push(l):s[u]=[l]}o.add(d.join(""))}}}for(const a of Object.keys(s))this.nodes.get(a).connections.edges.push(...s[a])});n(this,"render",()=>{this.drawCanvas.draw(this.nodes,this.drawOptions,this.drawStyles)});n(this,"updateZoom",e=>{let t=0;if(!e&&this.zoom>this.zoomMin&&(t=this.zoom-this.zoomStep),e&&this.zoom<this.zoomMax&&(t=this.zoom+this.zoomStep),!t)return;const o=this.zoom/t;this.nodes.forEach((s,a)=>{this.nodes.set(a,new k(s.x/o,s.y/o,s.z/o,s.connections))}),this.zoom=t,this.render()});n(this,"rotate",(e,t)=>{this.nodes.forEach((o,s)=>{const{x:a,y:r,z:i}=this.utils.calculateRotatedCoordinates(o.x,o.y,o.z,e,t,0,this.rotationRads);this.nodes.set(s,new k(a,r,i,o.connections))}),this.render()});this.drawOptions={nodes:"",edges:"both",faces:"",baseNodes:"both",baseEdges:"both",baseFaces:""},this.drawStyles={nodeColor:"blue",backNodeColor:"#FFC7C7",nodeSize:1,edgeColor:"black",backEdgeColor:"#D8D8D8",edgeWidth:1,faceColor:"blue",backFaceColor:"grey",baseNodeColor:"blue",backBaseNodeColor:"blue",baseNodeSize:4,baseEdgeColor:"red",backBaseEdgeColor:"#ffc7c7",baseEdgeWidth:4,baseFaceColor:"blue",backBaseFaceColor:"grey"},this.baseType="icosahedron",this.nodes=new Map,this.zoom=470,this.zoomMin=50,this.zoomStep=20,this.zoomMax=5e3,this.bases=new Map,this.frequency=10,this.rotationRads=.002,this.utils=new I,this.geodesicInterface=new D(e,t),this.drawCanvas=new Z(this.geodesicInterface.getCanvasElement(),950,950),this.geodesicInterface.generateEventListeners(this.rotate,this.updateZoom),this.generateBases(),this.generateGeo(),this.render()}}const M=document.querySelector("#app");new O(M,M);
