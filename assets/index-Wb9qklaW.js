var L=Object.defineProperty;var q=(m,t,e)=>t in m?L(m,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):m[t]=e;var o=(m,t,e)=>q(m,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const i of n)if(i.type==="childList")for(const r of i.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function e(n){const i={};return n.integrity&&(i.integrity=n.integrity),n.referrerPolicy&&(i.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?i.credentials="include":n.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(n){if(n.ep)return;n.ep=!0;const i=e(n);fetch(n.href,i)}})();class C{constructor(){o(this,"distanceF",(t,e,s,n,i,r)=>Math.sqrt((n-t)**2+(i-e)**2+(r-s)**2));o(this,"numFromChar",t=>t.charCodeAt(0)-97);o(this,"mapChar",t=>String.fromCharCode(t+97));o(this,"averageZ",(t,e)=>(t+e)/2);o(this,"mapToChars",t=>t.map(e=>this.mapChar(e)));o(this,"calculateRotatedCoordinates",(t,e,s,n,i,r,a)=>{const c=Math.sin(a*n),h=Math.cos(a*n),l=-Math.sin(a*i),u=Math.cos(a*i),f=Math.sin(a*r),d=Math.cos(a*r),g=t*d*h+e*d*c*l-e*f*u+s*d*c*u+s*f*l,p=t*f*h+e*f*c*l+e*d*u+s*f*c*u-s*d*l,y=-t*c+e*h*l+s*h*u;return{x:g,y:p,z:y}});o(this,"icosahedronIntermediateNode",(t,e,s,n,i,r,a,c,h,l,u,f)=>{const d=t+e+s,g=n*(t/d)+a*(e/d)+l*(s/d),p=i*(t/d)+c*(e/d)+u*(s/d),y=r*(t/d)+h*(e/d)+f*(s/d),x=this.distanceF(g,p,y,0,0,0);return{x:g/x,y:p/x,z:y/x}})}}class N{constructor(t,e,s){o(this,"utils");o(this,"ctx");o(this,"width");o(this,"height");o(this,"centerX");o(this,"centerY");o(this,"clearCanvas",()=>{this.ctx&&(this.ctx.fillStyle="white",this.ctx.fillRect(0,0,this.width,this.height))});o(this,"drawNode",(t,e,s,n)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.arc(t,e,s,0,2*Math.PI),this.ctx.strokeStyle="black",this.ctx.lineWidth=1,this.ctx.fillStyle=n,this.ctx.fill())});o(this,"drawEdge",(t,e,s,n,i)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.moveTo(t,e),this.ctx.lineTo(s,n),this.ctx.lineWidth=1,this.ctx.strokeStyle=i,this.ctx.lineTo(t,e),this.ctx.stroke())});o(this,"drawFace",(t,e)=>{if(this.ctx){this.ctx.beginPath(),this.ctx.strokeStyle="black",this.ctx.fillStyle=e,this.ctx.lineWidth=2,this.ctx.moveTo(t[0][0],t[0][1]);for(let s=1;s<t.length;s++)this.ctx.lineTo(t[s][0],t[s][1]);this.ctx.lineTo(t[0][0],t[0][1]),this.ctx.fill(),this.ctx.stroke()}});o(this,"drawNodes",t=>{const e=[];t.forEach((s,n)=>{if(s.z>=0){e.push(n);return}const i=this.centerX+s.x,r=this.centerY+s.y;this.drawNode(i,r,s.size,"#FFC7C7")});for(let s=0;s<e.length;s++){const n=t.get(e[s]),i=this.centerX+n.x,r=this.centerY+n.y;this.drawNode(i,r,n.size,n.color)}});o(this,"drawEdges",t=>{const e=[],s=[];for(const n of t.keys()){const i=t.get(n),r=i.connections.edges;for(let a=0;a<r.length;a++){if(this.utils.numFromChar(r[a])<this.utils.numFromChar(n))continue;const c=i.x+this.centerX,h=i.y+this.centerY,l=i.z,u=t.get(r[a]).x+this.centerX,f=t.get(r[a]).y+this.centerY,d=t.get(r[a]).z,g=this.utils.averageZ(l,d);g>0?e.push([c,h,u,f]):g===0?s.push([c,h,u,f]):this.drawEdge(c,h,u,f,"#DDE0FF")}}s.push(...e);for(let n=0;n<s.length;n++){const[i,r,a,c]=s[n];this.drawEdge(i,r,a,c,"blue")}});o(this,"drawFaces",t=>{const e=new Set;for(const s of t.keys()){const i=t.get(s).connections.faces;for(let r=0;r<i.length;r++){if(e.has(i[r].split("").sort().join("")))continue;const a=[];let c=0;for(const h of i[r]){const l=t.get(h).x+this.centerX,u=t.get(h).y+this.centerY;c+=t.get(h).z,a.push([l,u])}c/3>=0&&this.drawFace(a,"red"),e.add(i[r])}}});t.width=e,t.height=s,this.utils=new C,this.ctx=t.getContext("2d"),this.width=e,this.height=s,this.centerX=e/2,this.centerY=s/2}}class Y{constructor(t,e){o(this,"canvasParent");o(this,"panelParent");o(this,"panelId");o(this,"canvasId");o(this,"mouseIsDown");o(this,"generateInterface",()=>{this.generateCanvas(),this.generatePanel()});o(this,"generateCanvas",()=>{this.canvasParent.innerHTML=`
      ${this.canvasParent.innerHTML}
      <canvas id="${this.canvasId}" class="border-4 border-black cursor-grab"></canvas>
    `});o(this,"generatePanel",()=>{this.panelParent.innerHTML=`
      ${this.panelParent.innerHTML}
      <form id="${this.panelId}" class="w-96">
        <div class="flex justify-between">
          <p>frequency: </p>
          <input type="range" min="1" max="50" value="1">
        </div>
        <div class="flex justify-between">
          <p>Base: </p>
          <select>
            ${["icosahedron","cube","tetrahedron"].map((t,e)=>`<option key=${e} value="${t}">${t}</option>`)}
          </select>
        </div>
        <input class="cursor-pointer" type="submit" value="Generate">
      </form>
    `});o(this,"generateEventListeners",(t,e)=>{const s=document.querySelector(`#${this.canvasId}`);document.addEventListener("mouseup",()=>{this.mouseIsDown=!1}),s.addEventListener("mousedown",()=>{this.mouseIsDown=!0}),s.addEventListener("mousemove",n=>{this.mouseIsDown&&t(n.movementX,n.movementY)}),s.addEventListener("wheel",n=>{e(n.deltaY<0)})});o(this,"getCanvasElement",()=>document.querySelector(`#${this.canvasId}`));this.canvasParent=t,this.panelParent=e,this.canvasId="geodesic-canvas",this.panelId="geodesic-panel",this.mouseIsDown=!1,this.generateInterface()}}class w{constructor(t,e,s,n={edges:[],faces:[]}){o(this,"x");o(this,"y");o(this,"z");o(this,"color");o(this,"size");o(this,"connections");this.x=t,this.y=e,this.z=s,this.color="red",this.size=1,this.connections=n}}class k{constructor(t,e){o(this,"geodesicInterface");o(this,"drawCanvas");o(this,"utils");o(this,"bases");o(this,"baseType");o(this,"nodes");o(this,"zoom");o(this,"zoomMin");o(this,"zoomStep");o(this,"zoomMax");o(this,"frequency");o(this,"rotationRads");o(this,"generateBases",()=>{this.bases.set("cube",this.generateCubeBase()),this.bases.set("icosahedron",this.generateIcosahedronBase())});o(this,"generateIcosahedronBase",()=>{const t=new Map,e=(1+Math.sqrt(5))/4,s=.5,n=this.utils.distanceF(0,.5,e,0,0,0),i=(r,a,c,h)=>{t.set(this.utils.mapChar(h),new w(r*this.zoom,a*this.zoom,c*this.zoom,this.getIcosahedronConnections(h)))};for(let r=0;r<=3;r++){const a=e*(2*Math.floor(r/2)-1),c=s*(2*(r%2)-1);i(0,a/n,c/n,r)}for(let r=4;r<=7;r++){const a=e*(2*Math.floor(r%4/2)-1),c=s*(2*(r%2)-1);i(a/n,c/n,0,r)}for(let r=8;r<=11;r++){const a=s*(2*(r%2)-1),c=e*(2*Math.floor(r%4/2)-1);i(a/n,0,c/n,r)}return t});o(this,"generateCubeBase",()=>{const t=new Map,e=Math.sqrt(3);for(let s=-1;s<2;s+=2)for(let n=-1;n<2;n+=2)for(let i=-1;i<2;i+=2)t.set(this.utils.mapChar(t.size),new w(s/e*this.zoom,n/e*this.zoom,i/e*this.zoom,this.getCubeConnections(t.size)));return t});o(this,"getCubeConnections",t=>({edges:this.utils.mapToChars([t^1,t^2,t^4]),faces:[]}));o(this,"getIcosahedronConnections",t=>{const e=i=>(i^1)%12,s=i=>4*((Math.floor(i/4)+1)%3)+Math.floor(i/2)%2,n=i=>4*((Math.floor(i/4)+2)%3)+2*(i%2);return this.utils.mapToChars([t,e(t),s(t)]).sort().join(""),{edges:this.utils.mapToChars([e(t),s(t),s(t)+2,n(t),n(t)+1]),faces:[[e(t),s(t)],[s(t),n(t)],[n(t),n(t)+1],[n(t)+1,s(t)+2],[s(t)+2,e(t)]].map(i=>this.utils.mapToChars([t,...i]).join(""))}});o(this,"setBase",t=>{this.baseType=t,this.generateGeo()});o(this,"generateGeo",()=>{if(this.frequency===1){this.nodes=this.bases.get(this.baseType);return}switch(this.baseType){case"icosahedron":this.generateIcosahedronAtFrequency();break}});o(this,"generateIcosahedronAtFrequency",()=>{const t=this.bases.get(this.baseType),e=this.frequency,s=new Set;for(const n of t.keys()){const r=t.get(n).connections.faces;for(let a=0;a<r.length;a++){const c=r[a].split("").sort();if(!s.has(c.join(""))){for(let h=e;h>=0;h--)for(let l=e-h;l>=0;l--){const u={edges:[],faces:[]},f=e-h-l,d=`${h?`${c[0]}${h}`:""}${l?`${c[1]}${l}`:""}${f?`${c[2]}${f}`:""}`,g=`${h?`${c[0]}`:""}${l?`${c[1]}`:""}${f?`${c[2]}`:""}`;if(t.has(g)&&(u.edges=t.get(`${g}`).connections.edges.map(S=>S+`${e}`),u.faces=t.get(`${g}`).connections.faces),this.nodes.has(d))continue;const{x:p,y,z:x}=t.get(c[0]),{x:b,y:M,z:I}=t.get(c[1]),{x:v,y:$,z:T}=t.get(c[2]),{x:E,y:F,z:P}=this.utils.icosahedronIntermediateNode(h,l,f,p,y,x,b,M,I,v,$,T);this.nodes.set(d,new w(E*this.zoom,F*this.zoom,P*this.zoom,u))}s.add(c.join(""))}}}});o(this,"render",()=>{this.drawCanvas.clearCanvas(),this.drawCanvas.drawEdges(this.nodes),this.drawCanvas.drawNodes(this.nodes)});o(this,"updateZoom",t=>{let e=0;if(!t&&this.zoom>this.zoomMin&&(e=this.zoom-this.zoomStep),t&&this.zoom<this.zoomMax&&(e=this.zoom+this.zoomStep),!e)return;const s=this.zoom/e;this.nodes.forEach((n,i)=>{this.nodes.set(i,new w(n.x/s,n.y/s,n.z/s,n.connections))}),this.zoom=e,this.render()});o(this,"rotate",(t,e)=>{this.nodes.forEach((s,n)=>{const{x:i,y:r,z:a}=this.utils.calculateRotatedCoordinates(s.x,s.y,s.z,t,e,0,this.rotationRads);this.nodes.set(n,new w(i,r,a,s.connections))}),this.render()});this.baseType="icosahedron",this.nodes=new Map,this.zoom=380,this.zoomMin=50,this.zoomStep=20,this.zoomMax=5e3,this.bases=new Map,this.frequency=20,this.rotationRads=.008,this.utils=new C,this.geodesicInterface=new Y(t,e),this.drawCanvas=new N(this.geodesicInterface.getCanvasElement(),800,800),this.geodesicInterface.generateEventListeners(this.rotate,this.updateZoom),this.generateBases(),this.generateGeo(),this.render()}}const z=document.querySelector("#app");new k(z,z);
