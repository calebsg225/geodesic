var M=Object.defineProperty;var F=(l,t,s)=>t in l?M(l,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):l[t]=s;var r=(l,t,s)=>F(l,typeof t!="symbol"?t+"":t,s);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))o(e);new MutationObserver(e=>{for(const n of e)if(n.type==="childList")for(const i of n.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&o(i)}).observe(document,{childList:!0,subtree:!0});function s(e){const n={};return e.integrity&&(n.integrity=e.integrity),e.referrerPolicy&&(n.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?n.credentials="include":e.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function o(e){if(e.ep)return;e.ep=!0;const n=s(e);fetch(e.href,n)}})();class p{constructor(){r(this,"distanceF",(t,s,o,e,n,i)=>Math.sqrt((e-t)**2+(n-s)**2+(i-o)**2));r(this,"numFromChar",t=>t.charCodeAt(0)-97);r(this,"mapChar",t=>String.fromCharCode(t+97));r(this,"averageZ",(t,s)=>(t+s)/2);r(this,"mapToChars",t=>t.map(s=>this.mapChar(s)));r(this,"calculateRotatedCoordinates",(t,s,o,e,n,i,c)=>{const a=Math.sin(c*e),h=Math.cos(c*e),u=-Math.sin(c*n),d=Math.cos(c*n),f=Math.sin(c*i),g=Math.cos(c*i),m=t*g*h+s*g*a*u-s*f*d+o*g*a*d+o*f*u,b=t*f*h+s*f*a*u+s*g*d+o*f*a*d-o*g*u,z=-t*a+s*h*u+o*h*d;return{x:m,y:b,z}})}}class T{constructor(t,s,o){r(this,"utils");r(this,"ctx");r(this,"width");r(this,"height");r(this,"centerX");r(this,"centerY");r(this,"clearCanvas",()=>{this.ctx&&(this.ctx.fillStyle="white",this.ctx.fillRect(0,0,this.width,this.height))});r(this,"drawNode",(t,s,o,e)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.arc(t,s,o,0,2*Math.PI),this.ctx.strokeStyle="black",this.ctx.lineWidth=2,this.ctx.fillStyle=e,this.ctx.fill(),this.ctx.stroke())});r(this,"drawEdge",(t,s,o,e,n)=>{this.ctx&&(this.ctx.beginPath(),this.ctx.moveTo(t,s),this.ctx.lineTo(o,e),this.ctx.lineWidth=8,this.ctx.strokeStyle="black",this.ctx.stroke(),this.ctx.lineWidth=6,this.ctx.strokeStyle=n,this.ctx.lineTo(t,s),this.ctx.stroke())});r(this,"drawFace",(t,s)=>{if(this.ctx){this.ctx.beginPath(),this.ctx.strokeStyle="black",this.ctx.fillStyle=s,this.ctx.lineWidth=2,this.ctx.moveTo(t[0][0],t[0][1]);for(let o=1;o<t.length;o++)this.ctx.lineTo(t[o][0],t[o][1]);this.ctx.lineTo(t[0][0],t[0][1]),this.ctx.fill(),this.ctx.stroke()}});r(this,"drawNodes",t=>{const s=[];t.forEach((o,e)=>{if(o.z>=0){s.push(e);return}const n=this.centerX+o.x,i=this.centerY+o.y;this.drawNode(n,i,o.size,o.color)});for(let o=0;o<s.length;o++){const e=t.get(s[o]),n=this.centerX+e.x,i=this.centerY+e.y;this.drawNode(n,i,e.size,e.color)}});r(this,"drawEdges",t=>{const s=[],o=[];for(const e of t.keys()){const n=t.get(e),i=n.connections.edges;for(let c=0;c<i.length;c++){if(this.utils.numFromChar(i[c])<this.utils.numFromChar(e))continue;const a=n.x+this.centerX,h=n.y+this.centerY,u=n.z,d=t.get(i[c]).x+this.centerX,f=t.get(i[c]).y+this.centerY,g=t.get(i[c]).z,m=this.utils.averageZ(u,g);m>0?s.push([a,h,d,f]):m===0?o.push([a,h,d,f]):this.drawEdge(a,h,d,f,"#FFFFFF")}}o.push(...s);for(let e=0;e<o.length;e++){const[n,i,c,a]=o[e];this.drawEdge(n,i,c,a,"red")}});r(this,"drawFaces",t=>{const s=new Set;for(const o of t.keys()){const n=t.get(o).connections.faces;for(let i=0;i<n.length;i++){if(s.has(n[i]))continue;const c=[];let a=0;for(const h of n[i]){const u=t.get(h).x+this.centerX,d=t.get(h).y+this.centerY;a+=t.get(h).z,c.push([u,d])}a/3>=0&&this.drawFace(c,"red"),s.add(n[i])}}});this.utils=new p,this.ctx=t.getContext("2d"),this.width=s,this.height=o,this.centerX=s/2,this.centerY=o/2}}class x{constructor(t,s,o,e={edges:[],faces:[]}){r(this,"x");r(this,"y");r(this,"z");r(this,"color");r(this,"size");r(this,"connections");this.x=t,this.y=s,this.z=o,this.color="blue",this.size=8,this.connections=e}}class S{constructor(t,s,o,e){r(this,"drawCanvas");r(this,"utils");r(this,"element");r(this,"bases");r(this,"baseType");r(this,"nodes");r(this,"zoom");r(this,"frequency");r(this,"init",()=>{this.generateBases(),this.generateGeo()});r(this,"generateBases",()=>{this.bases.set("cube",this.generateCubeBase()),this.bases.set("icosahedron",this.generateIcosahedronBase())});r(this,"generateIcosahedronBase",()=>{const t=new Map,s=(1+Math.sqrt(5))/4,o=.5,e=this.utils.distanceF(0,.5,s,0,0,0),n=(i,c,a,h)=>{t.set(this.utils.mapChar(h),new x(i*this.zoom,c*this.zoom,a*this.zoom,this.getIcosahedronConnections(h)))};for(let i=0;i<=3;i++){const c=s*(2*Math.floor(i/2)-1),a=o*(2*(i%2)-1);n(0,c/e,a/e,i)}for(let i=4;i<=7;i++){const c=s*(2*Math.floor(i%4/2)-1),a=o*(2*(i%2)-1);n(c/e,a/e,0,i)}for(let i=8;i<=11;i++){const c=o*(2*(i%2)-1),a=s*(2*Math.floor(i%4/2)-1);n(c/e,0,a/e,i)}return t});r(this,"generateCubeBase",()=>{const t=new Map,s=Math.sqrt(3);for(let o=-1;o<2;o+=2)for(let e=-1;e<2;e+=2)for(let n=-1;n<2;n+=2)t.set(this.utils.mapChar(t.size),new x(o/s*this.zoom,e/s*this.zoom,n/s*this.zoom,this.getCubeConnections(t.size)));return t});r(this,"setZoom",t=>{this.zoom=t,this.render()});r(this,"updateCanvasSize",(t,s)=>{this.element.width=t,this.element.height=s});r(this,"getCubeConnections",t=>({edges:this.utils.mapToChars([t^1,t^2,t^4]),faces:[]}));r(this,"getIcosahedronConnections",t=>{const s=n=>(n^1)%12,o=n=>4*((Math.floor(n/4)+1)%3)+Math.floor(n/2)%2,e=n=>4*((Math.floor(n/4)+2)%3)+2*(n%2);return this.utils.mapToChars([t,s(t),o(t)]).sort().join(""),{edges:this.utils.mapToChars([s(t),o(t),o(t)+2,e(t),e(t)+1]),faces:[[s(t),o(t)],[o(t),e(t)],[e(t),e(t)+1],[e(t)+1,o(t)+2],[o(t)+2,s(t)]].map(n=>this.utils.mapToChars([t,...n]).sort().join(""))}});r(this,"setBase",t=>{this.baseType=t,this.generateGeo()});r(this,"generateGeo",()=>{this.frequency===1&&(this.nodes=this.bases.get(this.baseType))});r(this,"render",()=>{this.drawCanvas.clearCanvas(),this.drawCanvas.drawFaces(this.nodes)});r(this,"rotateMouse",(t,s)=>{this.nodes.forEach((e,n)=>{const{x:i,y:c,z:a}=this.utils.calculateRotatedCoordinates(e.x,e.y,e.z,t,s,0,.008);this.nodes.set(n,new x(i,c,a,e.connections))}),this.render()});this.drawCanvas=new T(t,s,o),this.utils=new p,t.width=s,t.height=o,this.element=t,this.baseType="cube",this.nodes=new Map,this.zoom=e,this.bases=new Map,this.frequency=1,this.init()}}document.querySelector("#app").innerHTML=`
  <canvas id="geodesic-canvas" class="border-4 border-black"></canvas>
  <section id="geodesic-interface" class="flex">
  </section>
`;const k=document.querySelector("#geodesic-canvas"),y=new S(k,800,800,300),C=document.querySelector("#geodesic-canvas");let w=!1;document.addEventListener("mouseup",()=>{w=!1});C.addEventListener("mousedown",()=>{w=!0});C.addEventListener("mousemove",l=>{w&&y.rotateMouse(l.movementX,l.movementY)});y.setBase("icosahedron");y.render();
